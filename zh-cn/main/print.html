<!DOCTYPE HTML>
<html lang="zh_CN" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Design Patterns</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script>
          (function () {
              // See these pages for details:
              // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
              // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
              let base = "https://rust-unofficial.github.io/patterns";
              let canonical_href = `${base}/zh_CN/print.md`;

              // mdbook gives us a string ending in ".md", we replace it with ".html":
              canonical_href = canonical_href.slice(0, -"md".length) + "html";
              if (canonical_href.endsWith("/index.html")) {
                  canonical_href = canonical_href.slice(0, -"index.html".length);
              }
        
              let link = document.createElement("link");
              link.rel = "canonical";
              link.href = canonical_href;
              document.head.appendChild(link);
          })()
        </script>
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="A catalogue of Rust design patterns, anti-patterns and idioms">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/css/language-picker.css">
        <link rel="stylesheet" href="./styles/last-changed.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-f3dd6c85.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-648e62ac.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Design Patterns</h1>

                    <div class="right-buttons">
                        <a href="rust-design-patterns.pdf" title="This book as a PDF" aria-label="This book as a PDF">
                            <span class=fa-svg id="open-pdf-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-unofficial/patterns" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="participation"><a class="header" href="#participation">Participation</a></h2>
<p>If you are interested in contributing to this book, check out the <a href="https://github.com/rust-unofficial/patterns/blob/master/CONTRIBUTING.md">contribution guidelines</a>.</p>
<h2 id="news"><a class="header" href="#news">News</a></h2>
<ul>
<li><strong>2025-12-14</strong>: New pattern added: <a href="#use-custom-traits-to-avoid-complex-type-bounds">Use custom traits to avoid complex type bounds</a></li>
<li><strong>2024-03-17</strong>: You can now download the <a href="https://rust-unofficial.github.io/patterns/rust-design-patterns.pdf">book in PDF format</a>.</li>
</ul>
<h2 id="design-patterns"><a class="header" href="#design-patterns">Design patterns</a></h2>
<p>In software development, we often come across problems that share similarities regardless of the environment they appear in. Although the implementation details are crucial to solve the task at hand, we may abstract from these particularities to find the common practices that are generically applicable.</p>
<p>Design patterns are a collection of reusable and tested solutions to recurring problems in engineering. They make our software more modular, maintainable, and extensible. Moreover, these patterns provide a common language for developers, making them an excellent tool for effective communication when problem-solving in teams.</p>
<p>Keep in mind: Each pattern comes with its own set of trade-offs. It’s crucial to focus on why you choose a particular pattern rather than just on how to implement it.<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup></p>
<h2 id="design-patterns-in-rust"><a class="header" href="#design-patterns-in-rust">Design patterns in Rust</a></h2>
<p>Rust is not object-oriented, and the combination of all its characteristics, such as functional elements, a strong type system, and the borrow checker, makes it unique. Because of this, Rust design patterns vary with respect to other traditional object-oriented programming languages. That’s why we decided to write this book. We hope you enjoy reading it! The book is divided in three main chapters:</p>
<ul>
<li><a href="#idioms">Idioms</a>: guidelines to follow when coding. They are the social norms of the community. You should break them only if you have a good reason for it.</li>
<li><a href="#design-patterns-1">Design patterns</a>: methods to solve common problems when coding.</li>
<li><a href="#anti-patterns">Anti-patterns</a>: methods to solve common problems when coding. However, while design patterns give us benefits, anti-patterns create more problems.</li>
</ul>
<footer id="last-change">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer>
<hr>
<ol class="footnote-definition">
<li id="footnote-1">
<p><a href="https://www.infoq.com/podcasts/software-architecture-hard-parts/">https://www.infoq.com/podcasts/software-architecture-hard-parts/</a> (<a href="https://web.archive.org/web/20240124025806/https://www.infoq.com/podcasts/software-architecture-hard-parts/">Archive</a>) <a href="#fr-1-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="translations"><a class="header" href="#translations">Translations</a></h1>
<p>We are utilizing <a href="https://github.com/google/mdbook-i18n-helpers">mdbook-i18n-helper</a>. Please read up on how to <em>add</em> and <em>update</em> translations in <a href="https://github.com/google/mdbook-i18n-helpers#creating-and-updating-translations">their repository</a></p>
<h2 id="external-translations"><a class="header" href="#external-translations">External translations</a></h2>
<ul>
<li><a href="https://fomalhauthmj.github.io/patterns/">简体中文</a></li>
</ul>
<p>If you want to add a translation, please open an issue in the <a href="https://github.com/rust-unofficial/patterns">main repository</a>.</p>
<footer id="last-change-1">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="idioms"><a class="header" href="#idioms">Idioms</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Programming_idiom">Idioms</a> are commonly used styles, guidelines and patterns largely agreed upon by a community. Writing idiomatic code allows other developers to understand better what is happening.</p>
<p>After all, the computer only cares about the machine code that is generated by the compiler. Instead, the source code is mainly beneficial to the developer. So, since we have this abstraction layer, why not make it more readable?</p>
<p>Remember the <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS principle</a>: “Keep It Simple, Stupid”. It claims that “most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided”.</p>
<blockquote>
<p>Code is there for humans, not computers, to understand.</p>
</blockquote>
<footer id="last-change-2">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="use-borrowed-types-for-arguments"><a class="header" href="#use-borrowed-types-for-arguments">Use borrowed types for arguments</a></h1>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Using a target of a deref coercion can increase the flexibility of your code when you are deciding which argument type to use for a function argument. In this way, the function will accept more input types.</p>
<p>This is not limited to slice-able or fat pointer types. In fact, you should always prefer using the <strong>borrowed type</strong> over <strong>borrowing the owned type</strong>. Such as <code>&amp;str</code> over <code>&amp;String</code>, <code>&amp;[T]</code> over <code>&amp;Vec&lt;T&gt;</code>, or <code>&amp;T</code> over <code>&amp;Box&lt;T&gt;</code>.</p>
<p>Using borrowed types you can avoid layers of indirection for those instances where the owned type already provides a layer of indirection. For instance, a <code>String</code> has a layer of indirection, so a <code>&amp;String</code> will have two layers of indirection. We can avoid this by using <code>&amp;str</code> instead, and letting <code>&amp;String</code> coerce to a <code>&amp;str</code> whenever the function is invoked.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>For this example, we will illustrate some differences for using <code>&amp;String</code> as a function argument versus using a <code>&amp;str</code>, but the ideas apply as well to using <code>&amp;Vec&lt;T&gt;</code> versus using a <code>&amp;[T]</code> or using a <code>&amp;Box&lt;T&gt;</code> versus a <code>&amp;T</code>.</p>
<p>Consider an example where we wish to determine if a word contains three consecutive vowels. We don’t need to own the string to determine this, so we will take a reference.</p>
<p>The code might look something like this:</p>
<pre class="playground"><code class="language-rust edition2024">fn three_vowels(word: &amp;String) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true;
                }
            }
            _ =&gt; vowel_count = 0,
        }
    }
    false
}

fn main() {
    let ferris = "Ferris".to_string();
    let curious = "Curious".to_string();
    println!("{}: {}", ferris, three_vowels(&amp;ferris));
    println!("{}: {}", curious, three_vowels(&amp;curious));

    // This works fine, but the following two lines would fail:
    // println!("Ferris: {}", three_vowels("Ferris"));
    // println!("Curious: {}", three_vowels("Curious"));
}</code></pre>
<p>This works fine because we are passing a <code>&amp;String</code> type as a parameter. If we remove the comments on the last two lines, the example will fail. This is because a <code>&amp;str</code> type will not coerce to a <code>&amp;String</code> type. We can fix this by simply modifying the type for our argument.</p>
<p>For instance, if we change our function declaration to:</p>
<pre><code class="language-rust ignore">fn three_vowels(word: &amp;str) -&gt; bool {</code></pre>
<p>then both versions will compile and print the same output.</p>
<pre><code class="language-bash">Ferris: false
Curious: true
</code></pre>
<p>But wait, that’s not all! There is more to this story. It’s likely that you may say to yourself: that doesn’t matter, I will never be using a <code>&amp;'static str</code> as an input anyways (as we did when we used <code>"Ferris"</code>). Even ignoring this special example, you may still find that using <code>&amp;str</code> will give you more flexibility than using a <code>&amp;String</code>.</p>
<p>Let’s now take an example where someone gives us a sentence, and we want to determine if any of the words in the sentence contain three consecutive vowels. We probably should make use of the function we have already defined and simply feed in each word from the sentence.</p>
<p>An example of this could look like this:</p>
<pre class="playground"><code class="language-rust edition2024">fn three_vowels(word: &amp;str) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true;
                }
            }
            _ =&gt; vowel_count = 0,
        }
    }
    false
}

fn main() {
    let sentence_string =
        "Once upon a time, there was a friendly curious crab named Ferris".to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word) {
            println!("{word} has three consecutive vowels!");
        }
    }
}</code></pre>
<p>Running this example using our function declared with an argument type <code>&amp;str</code> will yield</p>
<pre><code class="language-bash">curious has three consecutive vowels!
</code></pre>
<p>However, this example will not run when our function is declared with an argument type <code>&amp;String</code>. This is because string slices are a <code>&amp;str</code> and not a <code>&amp;String</code> which would require an allocation to be converted to <code>&amp;String</code> which is not implicit, whereas converting from <code>String</code> to <code>&amp;str</code> is cheap and implicit.</p>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/reference/type-coercions.html">Rust Language Reference on Type Coercions</a></li>
<li>For more discussion on how to handle <code>String</code> and <code>&amp;str</code> see <a href="https://web.archive.org/web/20201112023149/https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html">this blog series (2015)</a> by Herman J. Radtke III</li>
<li><a href="https://archive.ph/LBpD0">Steve Klabnik’s Blogpost on ‘When should I use String vs &amp;str?’</a></li>
</ul>
<footer id="last-change-3">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="concatenating-strings-with-format"><a class="header" href="#concatenating-strings-with-format">Concatenating strings with <code>format!</code></a></h1>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>It is possible to build up strings using the <code>push</code> and <code>push_str</code> methods on a mutable <code>String</code>, or using its <code>+</code> operator. However, it is often more convenient to use <code>format!</code>, especially where there is a mix of literal and non-literal strings.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn say_hello(name: &amp;str) -&gt; String {
    // We could construct the result string manually.
    // let mut result = "Hello ".to_owned();
    // result.push_str(name);
    // result.push('!');
    // result

    // But using format! is better.
    format!("Hello {name}!")
}
<span class="boring">}</span></code></pre>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<p>Using <code>format!</code> is usually the most succinct and readable way to combine strings.</p>
<h2 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h2>
<p>It is usually not the most efficient way to combine strings - a series of <code>push</code> operations on a mutable string is usually the most efficient (especially if the string has been pre-allocated to the expected size).</p>
<footer id="last-change-4">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>Rust does not have constructors as a language construct. Instead, the convention is to use an <a href="https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html#associated-functions">associated function</a> <code>new</code> to create an object:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::new(42);
/// assert_eq!(42, s.value());
/// ```
pub struct Second {
    value: u64,
}

impl Second {
    // Constructs a new instance of [`Second`].
    // Note this is an associated function - no self.
    pub fn new(value: u64) -&gt; Self {
        Self { value }
    }

    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}
<span class="boring">}</span></code></pre>
<h2 id="default-constructors"><a class="header" href="#default-constructors">Default Constructors</a></h2>
<p>Rust supports default constructors with the <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> trait:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::default();
/// assert_eq!(0, s.value());
/// ```
pub struct Second {
    value: u64,
}

impl Second {
    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}

impl Default for Second {
    fn default() -&gt; Self {
        Self { value: 0 }
    }
}
<span class="boring">}</span></code></pre>
<p><code>Default</code> can also be derived if all types of all fields implement <code>Default</code>, like they do with <code>Second</code>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Time in seconds.
///
/// # Example
///
/// ```
/// let s = Second::default();
/// assert_eq!(0, s.value());
/// ```
#[derive(Default)]
pub struct Second {
    value: u64,
}

impl Second {
    /// Returns the value in seconds.
    pub fn value(&amp;self) -&gt; u64 {
        self.value
    }
}
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> It is common and expected for types to implement both <code>Default</code> and an empty <code>new</code> constructor. <code>new</code> is the constructor convention in Rust, and users expect it to exist, so if it is reasonable for the basic constructor to take no arguments, then it should, even if it is functionally identical to default.</p>
<p><strong>Hint:</strong> The advantage of implementing or deriving <code>Default</code> is that your type can now be used where a <code>Default</code> implementation is required, most prominently, any of the <a href="https://doc.rust-lang.org/stable/std/?search=or_default"><code>*or_default</code> functions in the standard library</a>.</p>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<ul>
<li>
<p>The <a href="#the-default-trait">default idiom</a> for a more in-depth description of the <code>Default</code> trait.</p>
</li>
<li>
<p>The <a href="#builder">builder pattern</a> for constructing objects where there are multiple configurations.</p>
</li>
<li>
<p><a href="https://rust-lang.github.io/api-guidelines/interoperability.html#types-eagerly-implement-common-traits-c-common-traits">API Guidelines/C-COMMON-TRAITS</a> for implementing both, <code>Default</code> and <code>new</code>.</p>
</li>
</ul>
<footer id="last-change-5">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-default-trait"><a class="header" href="#the-default-trait">The <code>Default</code> Trait</a></h1>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>Many types in Rust have a <a href="#constructors">constructor</a>. However, this is <em>specific</em> to the type; Rust cannot abstract over “everything that has a <code>new()</code> method”. To allow this, the <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> trait was conceived, which can be used with containers and other generic types (e.g. see <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default()</code></a>). Notably, some containers already implement it where applicable.</p>
<p>Not only do one-element containers like <code>Cow</code>, <code>Box</code> or <code>Arc</code> implement <code>Default</code> for contained <code>Default</code> types, one can automatically <code>#[derive(Default)]</code> for structs whose fields all implement it, so the more types implement <code>Default</code>, the more useful it becomes.</p>
<p>On the other hand, constructors can take multiple arguments, while the <code>default()</code> method does not. There can even be multiple constructors with different names, but there can only be one <code>Default</code> implementation per type.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024">use std::{path::PathBuf, time::Duration};

// note that we can simply auto-derive Default here.
#[derive(Default, Debug, PartialEq)]
struct MyConfiguration {
    // Option defaults to None
    output: Option&lt;PathBuf&gt;,
    // Vecs default to empty vector
    search_path: Vec&lt;PathBuf&gt;,
    // Duration defaults to zero time
    timeout: Duration,
    // bool defaults to false
    check: bool,
}

impl MyConfiguration {
    // add setters here
}

fn main() {
    // construct a new instance with default values
    let mut conf = MyConfiguration::default();
    // do something with conf here
    conf.check = true;
    println!("conf = {conf:#?}");

    // partial initialization with default values, creates the same instance
    let conf1 = MyConfiguration {
        check: true,
        ..Default::default()
    };
    assert_eq!(conf, conf1);
}</code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See also</a></h2>
<ul>
<li>The <a href="#constructors">constructor</a> idiom is another way to generate instances that may or may not be “default”</li>
<li>The <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> documentation (scroll down for the list of implementors)</li>
<li><a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_or_default"><code>Option::unwrap_or_default()</code></a></li>
<li><a href="https://crates.io/crates/derive-new/"><code>derive(new)</code></a></li>
</ul>
<footer id="last-change-6">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="collections-are-smart-pointers"><a class="header" href="#collections-are-smart-pointers">Collections are smart pointers</a></h1>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<p>Use the <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> trait to treat collections like smart pointers, offering owning and borrowed views of data.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Vec&lt;T&gt; {
    data: RawVec&lt;T&gt;,
    //..
}

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];

    fn deref(&amp;self) -&gt; &amp;[T] {
        //..
    }
}</code></pre>
<p>A <code>Vec&lt;T&gt;</code> is an owning collection of <code>T</code>s, while a slice (<code>&amp;[T]</code>) is a borrowed collection of <code>T</code>s. Implementing <code>Deref</code> for <code>Vec</code> allows implicit dereferencing from <code>&amp;Vec&lt;T&gt;</code> to <code>&amp;[T]</code> and includes the relationship in auto-dereferencing searches. Most methods you might expect to be implemented for <code>Vec</code>s are instead implemented for slices.</p>
<p>Also <code>String</code> and <code>&amp;str</code> have a similar relation.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Ownership and borrowing are key aspects of the Rust language. Data structures must account for these semantics properly to give a good user experience. When implementing a data structure that owns its data, offering a borrowed view of that data allows for more flexible APIs.</p>
<h2 id="advantages-1"><a class="header" href="#advantages-1">Advantages</a></h2>
<p>Most methods can be implemented only for the borrowed view, they are then implicitly available for the owning view.</p>
<p>Gives clients a choice between borrowing or taking ownership of data.</p>
<h2 id="disadvantages-1"><a class="header" href="#disadvantages-1">Disadvantages</a></h2>
<p>Methods and traits only available via dereferencing are not taken into account when bounds checking, so generic programming with data structures using this pattern can get complex (see the <code>Borrow</code> and <code>AsRef</code> traits, etc.).</p>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>Smart pointers and collections are analogous: a smart pointer points to a single object, whereas a collection points to many objects. From the point of view of the type system, there is little difference between the two. A collection owns its data if the only way to access each datum is via the collection and the collection is responsible for deleting the data (even in cases of shared ownership, some kind of borrowed view may be appropriate). If a collection owns its data, it is usually useful to provide a view of the data as borrowed so that it can be referenced multiple times.</p>
<p>Most smart pointers (e.g., <code>Foo&lt;T&gt;</code>) implement <code>Deref&lt;Target=T&gt;</code>. However, collections will usually dereference to a custom type. <code>[T]</code> and <code>str</code> have some language support, but in the general case, this is not necessary. <code>Foo&lt;T&gt;</code> can implement <code>Deref&lt;Target=Bar&lt;T&gt;&gt;</code> where <code>Bar</code> is a dynamically sized type and <code>&amp;Bar&lt;T&gt;</code> is a borrowed view of the data in <code>Foo&lt;T&gt;</code>.</p>
<p>Commonly, ordered collections will implement <code>Index</code> for <code>Range</code>s to provide slicing syntax. The target will be the borrowed view.</p>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See also</a></h2>
<ul>
<li><a href="#deref-polymorphism">Deref polymorphism anti-pattern</a>.</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Documentation for <code>Deref</code> trait</a>.</li>
</ul>
<footer id="last-change-7">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="finalisation-in-destructors"><a class="header" href="#finalisation-in-destructors">Finalisation in destructors</a></h1>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<p>Rust does not provide the equivalent to <code>finally</code> blocks - code that will be executed no matter how a function is exited. Instead, an object’s destructor can be used to run code that must be run before exit.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><code class="language-rust ignore">fn baz() -&gt; Result&lt;(), ()&gt; {
    // some code
}

fn bar() -&gt; Result&lt;(), ()&gt; {
    // These don't need to be defined inside the function.
    struct Foo;

    // Implement a destructor for Foo.
    impl Drop for Foo {
        fn drop(&amp;mut self) {
            println!("exit");
        }
    }

    // The destructor of _exit will run however the function `bar` is exited.
    let _exit = Foo;
    // Implicit return with `?` operator.
    baz()?;
    // Normal return.
    Ok(())
}</code></pre>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>If a function has multiple return points, then executing code on exit becomes difficult and repetitive (and thus bug-prone). This is especially the case where return is implicit due to a macro. A common case is the <code>?</code> operator which returns if the result is an <code>Err</code>, but continues if it is <code>Ok</code>. <code>?</code> is used as an exception handling mechanism, but unlike Java (which has <code>finally</code>), there is no way to schedule code to run in both the normal and exceptional cases. Panicking will also exit a function early.</p>
<h2 id="advantages-2"><a class="header" href="#advantages-2">Advantages</a></h2>
<p>Code in destructors will (nearly) always be run - copes with panics, early returns, etc.</p>
<h2 id="disadvantages-2"><a class="header" href="#disadvantages-2">Disadvantages</a></h2>
<p>It is not guaranteed that destructors will run. For example, if there is an infinite loop in a function or if running a function crashes before exit. Destructors are also not run in the case of a panic in an already panicking thread. Therefore, destructors cannot be relied on as finalizers where it is absolutely essential that finalisation happens.</p>
<p>This pattern introduces some hard to notice, implicit code. Reading a function gives no clear indication of destructors to be run on exit. This can make debugging tricky.</p>
<p>Requiring an object and <code>Drop</code> impl just for finalisation is heavy on boilerplate.</p>
<h2 id="discussion-1"><a class="header" href="#discussion-1">Discussion</a></h2>
<p>There is some subtlety about how exactly to store the object used as a finalizer. It must be kept alive until the end of the function and must then be destroyed. The object must always be a value or uniquely owned pointer (e.g., <code>Box&lt;Foo&gt;</code>). If a shared pointer (such as <code>Rc</code>) is used, then the finalizer can be kept alive beyond the lifetime of the function. For similar reasons, the finalizer should not be moved or returned.</p>
<p>The finalizer must be assigned into a variable, otherwise it will be destroyed immediately, rather than when it goes out of scope. The variable name must start with <code>_</code> if the variable is only used as a finalizer, otherwise the compiler will warn that the finalizer is never used. However, do not call the variable <code>_</code> with no suffix - in that case it will be destroyed immediately.</p>
<p>In Rust, destructors are run when an object goes out of scope. This happens whether we reach the end of block, there is an early return, or the program panics. When panicking, Rust unwinds the stack running destructors for each object in each stack frame. So, destructors get called even if the panic happens in a function being called.</p>
<p>If a destructor panics while unwinding, there is no good action to take, so Rust aborts the thread immediately, without running further destructors. This means that destructors are not absolutely guaranteed to run. It also means that you must take extra care in your destructors not to panic, since it could leave resources in an unexpected state.</p>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See also</a></h2>
<p><a href="#raii-with-guards">RAII guards</a>.</p>
<footer id="last-change-8">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="memtake_-replace_-to-keep-owned-values-in-changed-enums"><a class="header" href="#memtake_-replace_-to-keep-owned-values-in-changed-enums"><code>mem::{take(_), replace(_)}</code> to keep owned values in changed enums</a></h1>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<p>Say we have a <code>&amp;mut MyEnum</code> which has (at least) two variants, <code>A { name: String, x: u8 }</code> and <code>B { name: String }</code>. Now we want to change <code>MyEnum::A</code> to a <code>B</code> if <code>x</code> is zero, while keeping <code>MyEnum::B</code> intact.</p>
<p>We can do this without cloning the <code>name</code>.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MyEnum {
    A { name: String, x: u8 },
    B { name: String },
}

fn a_to_b(e: &amp;mut MyEnum) {
    if let MyEnum::A { name, x: 0 } = e {
        // This takes out our `name` and puts in an empty String instead
        // (note that empty strings don't allocate).
        // Then, construct the new enum variant (which will
        // be assigned to `*e`).
        *e = MyEnum::B {
            name: mem::take(name),
        }
    }
}
<span class="boring">}</span></code></pre>
<p>This also works with more variants:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MultiVariateEnum {
    A { name: String },
    B { name: String },
    C,
    D,
}

fn swizzle(e: &amp;mut MultiVariateEnum) {
    use MultiVariateEnum::*;
    *e = match e {
        // Ownership rules do not allow taking `name` by value, but we cannot
        // take the value out of a mutable reference, unless we replace it:
        A { name } =&gt; B {
            name: mem::take(name),
        },
        B { name } =&gt; A {
            name: mem::take(name),
        },
        C =&gt; D,
        D =&gt; C,
    }
}
<span class="boring">}</span></code></pre>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p>When working with enums, we may want to change an enum value in place, perhaps to another variant. This is usually done in two phases to keep the borrow checker happy. In the first phase, we observe the existing value and look at its parts to decide what to do next. In the second phase we may conditionally change the value (as in the example above).</p>
<p>The borrow checker won’t allow us to take out <code>name</code> of the enum (because <em>something</em> must be there.) We could of course <code>.clone()</code> name and put the clone into our <code>MyEnum::B</code>, but that would be an instance of the <a href="#clone-to-satisfy-the-borrow-checker">Clone to satisfy the borrow checker</a> anti-pattern. Anyway, we can avoid the extra allocation by changing <code>e</code> with only a mutable borrow.</p>
<p><code>mem::take</code> lets us swap out the value, replacing it with its default value, and returning the previous value. For <code>String</code>, the default value is an empty <code>String</code>, which does not need to allocate. As a result, we get the original <code>name</code> <em>as an owned value</em>. We can then wrap this in another enum.</p>
<p><strong>NOTE:</strong> <code>mem::replace</code> is very similar, but allows us to specify what to replace the value with. An equivalent to our <code>mem::take</code> line would be <code>mem::replace(name, String::new())</code>.</p>
<p>Note, however, that if we are using an <code>Option</code> and want to replace its value with a <code>None</code>, <code>Option</code>’s <code>take()</code> method provides a shorter and more idiomatic alternative.</p>
<h2 id="advantages-3"><a class="header" href="#advantages-3">Advantages</a></h2>
<p>Look ma, no allocation! Also you may feel like Indiana Jones while doing it.</p>
<h2 id="disadvantages-3"><a class="header" href="#disadvantages-3">Disadvantages</a></h2>
<p>This gets a bit wordy. Getting it wrong repeatedly will make you hate the borrow checker. The compiler may fail to optimize away the double store, resulting in reduced performance as opposed to what you’d do in unsafe languages.</p>
<p>Furthermore, the type you are taking needs to implement the <a href="#the-default-trait"><code>Default</code> trait</a>. However, if the type you’re working with doesn’t implement this, you can instead use <code>mem::replace</code>.</p>
<h2 id="discussion-2"><a class="header" href="#discussion-2">Discussion</a></h2>
<p>This pattern is only of interest in Rust. In GC’d languages, you’d take the reference to the value by default (and the GC would keep track of refs), and in other low-level languages like C you’d simply alias the pointer and fix things later.</p>
<p>However, in Rust, we have to do a little more work to do this. An owned value may only have one owner, so to take it out, we need to put something back in – like Indiana Jones, replacing the artifact with a bag of sand.</p>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See also</a></h2>
<p>This gets rid of the <a href="#clone-to-satisfy-the-borrow-checker">Clone to satisfy the borrow checker</a> anti-pattern in a specific case.</p>
<footer id="last-change-9">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="on-stack-dynamic-dispatch"><a class="header" href="#on-stack-dynamic-dispatch">On-Stack Dynamic Dispatch</a></h1>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<p>We can dynamically dispatch over multiple values, however, to do so, we need to declare multiple variables to bind differently-typed objects. To extend the lifetime as necessary, we can use deferred conditional initialization, as seen below:</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024">use std::io;
use std::fs;

<span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span class="boring">let arg = "-";
</span>
// We need to describe the type to get dynamic dispatch.
let readable: &amp;mut dyn io::Read = if arg == "-" {
    &amp;mut io::stdin()
} else {
    &amp;mut fs::File::open(arg)?
};

// Read from `readable` here.

<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h2>
<p>Rust monomorphises code by default. This means a copy of the code will be generated for each type it is used with and optimized independently. While this allows for very fast code on the hot path, it also bloats the code in places where performance is not of the essence, thus costing compile time and cache usage.</p>
<p>Luckily, Rust allows us to use dynamic dispatch, but we have to explicitly ask for it.</p>
<h2 id="advantages-4"><a class="header" href="#advantages-4">Advantages</a></h2>
<p>We do not need to allocate anything on the heap. Neither do we need to initialize something we won’t use later, nor do we need to monomorphize the whole code that follows to work with both <code>File</code> or <code>Stdin</code>.</p>
<h2 id="disadvantages-4"><a class="header" href="#disadvantages-4">Disadvantages</a></h2>
<p>Before Rust 1.79.0, the code needed two <code>let</code> bindings with deferred initialization, which made up more moving parts than the <code>Box</code>-based version:</p>
<pre><code class="language-rust ignore">// We still need to ascribe the type for dynamic dispatch.
let readable: Box&lt;dyn io::Read&gt; = if arg == "-" {
    Box::new(io::stdin())
} else {
    Box::new(fs::File::open(arg)?)
};
// Read from `readable` here.</code></pre>
<p>Luckily, this disadvantage is now gone. Yay!</p>
<h2 id="discussion-3"><a class="header" href="#discussion-3">Discussion</a></h2>
<p>Since Rust 1.79.0, the compiler will automatically extend the lifetimes of temporary values within <code>&amp;</code> or <code>&amp;mut</code> as long as possible within the scope of the function.</p>
<p>This means we can simply use a <code>&amp;mut</code> value here without worrying about placing the contents into some <code>let</code> binding (which would have been needed for deferred initialization, which was the solution used before that change).</p>
<p>We still have a place for each value (even if that place is temporary), the compiler knows the size of each value and each borrowed value outlives all references borrowed from it.</p>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See also</a></h2>
<ul>
<li><a href="#finalisation-in-destructors">Finalisation in destructors</a> and <a href="#raii-with-guards">RAII guards</a> can benefit from tight control over lifetimes.</li>
<li>For conditionally filled <code>Option&lt;&amp;T&gt;</code>s of (mutable) references, one can initialize an <code>Option&lt;T&gt;</code> directly and use its <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref"><code>.as_ref()</code></a> method to get an optional reference.</li>
</ul>
<footer id="last-change-10">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="ffi-idioms"><a class="header" href="#ffi-idioms">FFI Idioms</a></h1>
<p>Writing FFI code is an entire course in itself. However, there are several idioms here that can act as pointers, and avoid traps for inexperienced users of <code>unsafe</code> Rust.</p>
<p>This section contains idioms that may be useful when doing FFI.</p>
<ol>
<li>
<p><a href="#error-handling-in-ffi">Idiomatic Errors</a> - Error handling with integer codes and sentinel return values (such as <code>NULL</code> pointers)</p>
</li>
<li>
<p><a href="#accepting-strings">Accepting Strings</a> with minimal unsafe code</p>
</li>
<li>
<p><a href="#passing-strings">Passing Strings</a> to FFI functions</p>
</li>
</ol>
<footer id="last-change-11">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-handling-in-ffi"><a class="header" href="#error-handling-in-ffi">Error Handling in FFI</a></h1>
<h2 id="description-8"><a class="header" href="#description-8">Description</a></h2>
<p>In foreign languages like C, errors are represented by return codes. However, Rust’s type system allows much more rich error information to be captured and propagated through a full type.</p>
<p>This best practice shows different kinds of error codes, and how to expose them in a usable way:</p>
<ol>
<li>Flat Enums should be converted to integers and returned as codes.</li>
<li>Structured Enums should be converted to an integer code with a string error message for detail.</li>
<li>Custom Error Types should become “transparent”, with a C representation.</li>
</ol>
<h2 id="code-example"><a class="header" href="#code-example">Code Example</a></h2>
<h3 id="flat-enums"><a class="header" href="#flat-enums">Flat Enums</a></h3>
<pre><code class="language-rust ignore">enum DatabaseError {
    IsReadOnly = 1,    // user attempted a write operation
    IOError = 2,       // user should read the C errno() for what it was
    FileCorrupted = 3, // user should run a repair tool to recover it
}

impl From&lt;DatabaseError&gt; for libc::c_int {
    fn from(e: DatabaseError) -&gt; libc::c_int {
        (e as i8).into()
    }
}</code></pre>
<h3 id="structured-enums"><a class="header" href="#structured-enums">Structured Enums</a></h3>
<pre><code class="language-rust ignore">pub mod errors {
    enum DatabaseError {
        IsReadOnly,
        IOError(std::io::Error),
        FileCorrupted(String), // message describing the issue
    }

    impl From&lt;DatabaseError&gt; for libc::c_int {
        fn from(e: DatabaseError) -&gt; libc::c_int {
            match e {
                DatabaseError::IsReadOnly =&gt; 1,
                DatabaseError::IOError(_) =&gt; 2,
                DatabaseError::FileCorrupted(_) =&gt; 3,
            }
        }
    }
}

pub mod c_api {
    use super::errors::DatabaseError;
    use core::ptr;

    #[no_mangle]
    pub extern "C" fn db_error_description(
        e: Option&lt;ptr::NonNull&lt;DatabaseError&gt;&gt;,
    ) -&gt; Option&lt;ptr::NonNull&lt;libc::c_char&gt;&gt; {
        // SAFETY: we assume that the lifetime of `e` is greater than
        // the current stack frame.
        let error = unsafe { e?.as_ref() };

        let error_str: String = match error {
            DatabaseError::IsReadOnly =&gt; {
                format!("cannot write to read-only database")
            }
            DatabaseError::IOError(e) =&gt; {
                format!("I/O Error: {e}")
            }
            DatabaseError::FileCorrupted(s) =&gt; {
                format!("File corrupted, run repair: {}", &amp;s)
            }
        };

        let error_bytes = error_str.as_bytes();

        let c_error = unsafe {
            // SAFETY: copying error_bytes to an allocated buffer with a '\0'
            // byte at the end.
            let buffer = ptr::NonNull::&lt;u8&gt;::new(libc::malloc(error_bytes.len() + 1).cast())?;

            buffer
                .as_ptr()
                .copy_from_nonoverlapping(error_bytes.as_ptr(), error_bytes.len());
            buffer.as_ptr().add(error_bytes.len()).write(0_u8);
            buffer
        };

        Some(c_error.cast())
    }
}</code></pre>
<h3 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h3>
<pre><code class="language-rust ignore">struct ParseError {
    expected: char,
    line: u32,
    ch: u16,
}

impl ParseError {
    /* ... */
}

/* Create a second version which is exposed as a C structure */
#[repr(C)]
pub struct parse_error {
    pub expected: libc::c_char,
    pub line: u32,
    pub ch: u16,
}

impl From&lt;ParseError&gt; for parse_error {
    fn from(e: ParseError) -&gt; parse_error {
        let ParseError { expected, line, ch } = e;
        parse_error { expected, line, ch }
    }
}</code></pre>
<h2 id="advantages-5"><a class="header" href="#advantages-5">Advantages</a></h2>
<p>This ensures that the foreign language has clear access to error information while not compromising the Rust code’s API at all.</p>
<h2 id="disadvantages-5"><a class="header" href="#disadvantages-5">Disadvantages</a></h2>
<p>It’s a lot of typing, and some types may not be able to be converted easily to C.</p>
<footer id="last-change-12">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="accepting-strings"><a class="header" href="#accepting-strings">Accepting Strings</a></h1>
<h2 id="description-9"><a class="header" href="#description-9">Description</a></h2>
<p>When accepting strings via FFI through pointers, there are two principles that should be followed:</p>
<ol>
<li>Keep foreign strings “borrowed”, rather than copying them directly.</li>
<li>Minimize the amount of complexity and <code>unsafe</code> code involved in converting from a C-style string to native Rust strings.</li>
</ol>
<h2 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h2>
<p>The strings used in C have different behaviours to those used in Rust, namely:</p>
<ul>
<li>C strings are null-terminated while Rust strings store their length</li>
<li>C strings can contain any arbitrary non-zero byte while Rust strings must be UTF-8</li>
<li>C strings are accessed and manipulated using <code>unsafe</code> pointer operations while interactions with Rust strings go through safe methods</li>
</ul>
<p>The Rust standard library comes with C equivalents of Rust’s <code>String</code> and <code>&amp;str</code> called <code>CString</code> and <code>&amp;CStr</code>, that allow us to avoid a lot of the complexity and <code>unsafe</code> code involved in converting between C strings and Rust strings.</p>
<p>The <code>&amp;CStr</code> type also allows us to work with borrowed data, meaning passing strings between Rust and C is a zero-cost operation.</p>
<h2 id="code-example-1"><a class="header" href="#code-example-1">Code Example</a></h2>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    /// Log a message at the specified level.
    ///
    /// # Safety
    ///
    /// It is the caller's guarantee to ensure `msg`:
    ///
    /// - is not a null pointer
    /// - points to valid, initialized data
    /// - points to memory ending in a null byte
    /// - won't be mutated for the duration of this function call
    #[no_mangle]
    pub unsafe extern "C" fn mylib_log(msg: *const libc::c_char, level: libc::c_int) {
        let level: crate::LogLevel = match level { /* ... */ };

        // SAFETY: The caller has already guaranteed this is okay (see the
        // `# Safety` section of the doc-comment).
        let msg_str: &amp;str = match std::ffi::CStr::from_ptr(msg).to_str() {
            Ok(s) =&gt; s,
            Err(e) =&gt; {
                crate::log_error("FFI string conversion failed");
                return;
            }
        };

        crate::log(msg_str, level);
    }
}</code></pre>
<h2 id="advantages-6"><a class="header" href="#advantages-6">Advantages</a></h2>
<p>The example is written to ensure that:</p>
<ol>
<li>The <code>unsafe</code> block is as small as possible.</li>
<li>The pointer with an “untracked” lifetime becomes a “tracked” shared reference</li>
</ol>
<p>Consider an alternative, where the string is actually copied:</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    pub extern "C" fn mylib_log(msg: *const libc::c_char, level: libc::c_int) {
        // DO NOT USE THIS CODE.
        // IT IS UGLY, VERBOSE, AND CONTAINS A SUBTLE BUG.

        let level: crate::LogLevel = match level { /* ... */ };

        let msg_len = unsafe { /* SAFETY: strlen is what it is, I guess? */
            libc::strlen(msg)
        };

        let mut msg_data = Vec::with_capacity(msg_len + 1);

        let msg_cstr: std::ffi::CString = unsafe {
            // SAFETY: copying from a foreign pointer expected to live
            // for the entire stack frame into owned memory
            std::ptr::copy_nonoverlapping(msg, msg_data.as_mut(), msg_len);

            msg_data.set_len(msg_len + 1);

            std::ffi::CString::from_vec_with_nul(msg_data).unwrap()
        }

        let msg_str: String = unsafe {
            match msg_cstr.into_string() {
                Ok(s) =&gt; s,
                Err(e) =&gt; {
                    crate::log_error("FFI string conversion failed");
                    return;
                }
            }
        };

        crate::log(&amp;msg_str, level);
    }
}</code></pre>
<p>This code is inferior to the original in two respects:</p>
<ol>
<li>There is much more <code>unsafe</code> code, and more importantly, more invariants it must uphold.</li>
<li>Due to the extensive arithmetic required, there is a bug in this version that cases Rust <code>undefined behaviour</code>.</li>
</ol>
<p>The bug here is a simple mistake in pointer arithmetic: the string was copied, all <code>msg_len</code> bytes of it. However, the <code>NUL</code> terminator at the end was not.</p>
<p>The Vector then had its size <em>set</em> to the length of the <em>zero padded string</em> – rather than <em>resized</em> to it, which could have added a zero at the end. As a result, the last byte in the Vector is uninitialized memory. When the <code>CString</code> is created at the bottom of the block, its read of the Vector will cause <code>undefined behaviour</code>!</p>
<p>Like many such issues, this would be difficult issue to track down. Sometimes it would panic because the string was not <code>UTF-8</code>, sometimes it would put a weird character at the end of the string, sometimes it would just completely crash.</p>
<h2 id="disadvantages-6"><a class="header" href="#disadvantages-6">Disadvantages</a></h2>
<p>None?</p>
<footer id="last-change-13">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="passing-strings"><a class="header" href="#passing-strings">Passing Strings</a></h1>
<h2 id="description-10"><a class="header" href="#description-10">Description</a></h2>
<p>When passing strings to FFI functions, there are four principles that should be followed:</p>
<ol>
<li>Make the lifetime of owned strings as long as possible.</li>
<li>Minimize <code>unsafe</code> code during the conversion.</li>
<li>If the C code can modify the string data, use <code>Vec</code> instead of <code>CString</code>.</li>
<li>Unless the Foreign Function API requires it, the ownership of the string should not transfer to the callee.</li>
</ol>
<h2 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h2>
<p>Rust has built-in support for C-style strings with its <code>CString</code> and <code>CStr</code> types. However, there are different approaches one can take with strings that are being sent to a foreign function call from a Rust function.</p>
<p>The best practice is simple: use <code>CString</code> in such a way as to minimize <code>unsafe</code> code. However, a secondary caveat is that <em>the object must live long enough</em>, meaning the lifetime should be maximized. In addition, the documentation explains that “round-tripping” a <code>CString</code> after modification is UB, so additional work is necessary in that case.</p>
<h2 id="code-example-2"><a class="header" href="#code-example-2">Code Example</a></h2>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    extern "C" {
        fn seterr(message: *const libc::c_char);
        fn geterr(buffer: *mut libc::c_char, size: libc::c_int) -&gt; libc::c_int;
    }

    fn report_error_to_ffi&lt;S: Into&lt;String&gt;&gt;(err: S) -&gt; Result&lt;(), std::ffi::NulError&gt; {
        let c_err = std::ffi::CString::new(err.into())?;

        unsafe {
            // SAFETY: calling an FFI whose documentation says the pointer is
            // const, so no modification should occur
            seterr(c_err.as_ptr());
        }

        Ok(())
        // The lifetime of c_err continues until here
    }

    fn get_error_from_ffi() -&gt; Result&lt;String, std::ffi::IntoStringError&gt; {
        let mut buffer = vec![0u8; 1024];
        unsafe {
            // SAFETY: calling an FFI whose documentation implies
            // that the input need only live as long as the call
            let written: usize = geterr(buffer.as_mut_ptr(), 1023).into();

            buffer.truncate(written + 1);
        }

        std::ffi::CString::new(buffer).unwrap().into_string()
    }
}</code></pre>
<h2 id="advantages-7"><a class="header" href="#advantages-7">Advantages</a></h2>
<p>The example is written in a way to ensure that:</p>
<ol>
<li>The <code>unsafe</code> block is as small as possible.</li>
<li>The <code>CString</code> lives long enough.</li>
<li>Errors with typecasts are always propagated when possible.</li>
</ol>
<p>A common mistake (so common it’s in the documentation) is to not use the variable in the first block:</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    fn report_error&lt;S: Into&lt;String&gt;&gt;(err: S) -&gt; Result&lt;(), std::ffi::NulError&gt; {
        unsafe {
            // SAFETY: whoops, this contains a dangling pointer!
            seterr(std::ffi::CString::new(err.into())?.as_ptr());
        }
        Ok(())
    }
}</code></pre>
<p>This code will result in a dangling pointer, because the lifetime of the <code>CString</code> is not extended by the pointer creation, unlike if a reference were created.</p>
<p>Another issue frequently raised is that the initialization of a 1k vector of zeroes is “slow”. However, recent versions of Rust actually optimize that particular macro to a call to <code>zmalloc</code>, meaning it is as fast as the operating system’s ability to return zeroed memory (which is quite fast).</p>
<h2 id="disadvantages-7"><a class="header" href="#disadvantages-7">Disadvantages</a></h2>
<p>None?</p>
<footer id="last-change-14">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="iterating-over-an-option"><a class="header" href="#iterating-over-an-option">Iterating over an <code>Option</code></a></h1>
<h2 id="description-11"><a class="header" href="#description-11">Description</a></h2>
<p><code>Option</code> can be viewed as a container that contains either zero or one element. In particular, it implements the <code>IntoIterator</code> trait, and as such can be used with generic code that needs such a type.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Since <code>Option</code> implements <code>IntoIterator</code>, it can be used as an argument to <a href="https://doc.rust-lang.org/std/iter/trait.Extend.html#tymethod.extend"><code>.extend()</code></a>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let turing = Some("Turing");
let mut logicians = vec!["Curry", "Kleene", "Markov"];

logicians.extend(turing);

// equivalent to
if let Some(turing_inner) = turing {
    logicians.push(turing_inner);
}
<span class="boring">}</span></code></pre>
<p>If you need to tack an <code>Option</code> to the end of an existing iterator, you can pass it to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>.chain()</code></a>:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let turing = Some("Turing");
let logicians = vec!["Curry", "Kleene", "Markov"];

for logician in logicians.iter().chain(turing.iter()) {
    println!("{logician} is a logician");
}
<span class="boring">}</span></code></pre>
<p>Note that if the <code>Option</code> is always <code>Some</code>, then it is more idiomatic to use <a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>std::iter::once</code></a> on the element instead.</p>
<p>Also, since <code>Option</code> implements <code>IntoIterator</code>, it’s possible to iterate over it using a <code>for</code> loop. This is equivalent to matching it with <code>if let Some(..)</code>, and in most cases you should prefer the latter.</p>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See also</a></h2>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>std::iter::once</code></a> is an iterator which yields exactly one element. It’s a more readable alternative to <code>Some(foo).into_iter()</code>.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map"><code>Iterator::filter_map</code></a> is a version of <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>Iterator::map</code></a>, specialized to mapping functions which return <code>Option</code>.</p>
</li>
<li>
<p>The <a href="https://crates.io/crates/ref_slice"><code>ref_slice</code></a> crate provides functions for converting an <code>Option</code> to a zero- or one-element slice.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html">Documentation for <code>Option&lt;T&gt;</code></a></p>
</li>
</ul>
<footer id="last-change-15">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="pass-variables-to-closure"><a class="header" href="#pass-variables-to-closure">Pass variables to closure</a></h1>
<h2 id="description-12"><a class="header" href="#description-12">Description</a></h2>
<p>By default, closures capture their environment by borrowing. Or you can use a <code>move</code>-closure to move the whole environment. However, often you want to move just some variables to the closure, give it a copy of some data, pass by reference, or perform some other transformation.</p>
<p>Use variable rebinding in a separate scope for that.</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<p>Use</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
let closure = {
    // `num1` is moved
    let num2 = num2.clone();  // `num2` is cloned
    let num3 = num3.as_ref();  // `num3` is borrowed
    move || {
        *num1 + *num2 + *num3;
    }
};
<span class="boring">}</span></code></pre>
<p>instead of</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);

let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
    *num1 + *num2_cloned + *num3_borrowed;
};
<span class="boring">}</span></code></pre>
<h2 id="advantages-8"><a class="header" href="#advantages-8">Advantages</a></h2>
<p>Copied data are grouped together with the closure definition, so their purpose is more clear, and they will be dropped immediately even if they are not consumed by the closure.</p>
<p>The closure uses the same variable names as the surrounding code, whether data are copied or moved.</p>
<h2 id="disadvantages-8"><a class="header" href="#disadvantages-8">Disadvantages</a></h2>
<p>Additional indentation of the closure body.</p>
<footer id="last-change-16">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="non_exhaustive-and-private-fields-for-extensibility"><a class="header" href="#non_exhaustive-and-private-fields-for-extensibility"><code>#[non_exhaustive]</code> and private fields for extensibility</a></h1>
<h2 id="description-13"><a class="header" href="#description-13">Description</a></h2>
<p>A small set of scenarios exist where a library author may want to add public fields to a public struct or new variants to an enum without breaking backwards compatibility.</p>
<p>Rust offers two solutions to this problem:</p>
<ul>
<li>
<p>Use <code>#[non_exhaustive]</code> on <code>struct</code>s, <code>enum</code>s, and <code>enum</code> variants. For extensive documentation on all the places where <code>#[non_exhaustive]</code> can be used, see <a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute">the docs</a>.</p>
</li>
<li>
<p>You may add a private field to a struct to prevent it from being directly instantiated or matched against (see Alternative)</p>
</li>
</ul>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    // Public struct.
    #[non_exhaustive]
    pub struct S {
        pub foo: i32,
    }

    #[non_exhaustive]
    pub enum AdmitMoreVariants {
        VariantA,
        VariantB,
        #[non_exhaustive]
        VariantC {
            a: String,
        },
    }
}

fn print_matched_variants(s: a::S) {
    // Because S is `#[non_exhaustive]`, it cannot be named here and
    // we must use `..` in the pattern.
    let a::S { foo: _, .. } = s;

    let some_enum = a::AdmitMoreVariants::VariantA;
    match some_enum {
        a::AdmitMoreVariants::VariantA =&gt; println!("it's an A"),
        a::AdmitMoreVariants::VariantB =&gt; println!("it's a b"),

        // .. required because this variant is non-exhaustive as well
        a::AdmitMoreVariants::VariantC { a, .. } =&gt; println!("it's a c"),

        // The wildcard match is required because more variants may be
        // added in the future
        _ =&gt; println!("it's a new variant"),
    }
}
<span class="boring">}</span></code></pre>
<h2 id="alternative-private-fields-for-structs"><a class="header" href="#alternative-private-fields-for-structs">Alternative: <code>Private fields</code> for structs</a></h2>
<p><code>#[non_exhaustive]</code> only works across crate boundaries. Within a crate, the private field method may be used.</p>
<p>Adding a field to a struct is a mostly backwards compatible change. However, if a client uses a pattern to deconstruct a struct instance, they might name all the fields in the struct and adding a new one would break that pattern. The client could name some fields and use <code>..</code> in the pattern, in which case adding another field is backwards compatible. Making at least one of the struct’s fields private forces clients to use the latter form of patterns, ensuring that the struct is future-proof.</p>
<p>The downside of this approach is that you might need to add an otherwise unneeded field to the struct. You can use the <code>()</code> type so that there is no runtime overhead and prepend <code>_</code> to the field name to avoid the unused field warning.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S {
    pub a: i32,
    // Because `b` is private, you cannot match on `S` without using `..` and `S`
    //  cannot be directly instantiated or matched against
    _b: (),
}
<span class="boring">}</span></code></pre>
<h2 id="discussion-4"><a class="header" href="#discussion-4">Discussion</a></h2>
<p>On <code>struct</code>s, <code>#[non_exhaustive]</code> allows adding additional fields in a backwards compatible way. It will also prevent clients from using the struct constructor, even if all the fields are public. This may be helpful, but it’s worth considering if you <em>want</em> an additional field to be found by clients as a compiler error rather than something that may be silently undiscovered.</p>
<p><code>#[non_exhaustive]</code> can be applied to enum variants as well. A <code>#[non_exhaustive]</code> variant behaves in the same way as a <code>#[non_exhaustive]</code> struct.</p>
<p>Use this deliberately and with caution: incrementing the major version when adding fields or variants is often a better option. <code>#[non_exhaustive]</code> may be appropriate in scenarios where you’re modeling an external resource that may change out-of-sync with your library, but is not a general purpose tool.</p>
<h3 id="disadvantages-9"><a class="header" href="#disadvantages-9">Disadvantages</a></h3>
<p><code>#[non_exhaustive]</code> can make your code much less ergonomic to use, especially when forced to handle unknown enum variants. It should only be used when these sorts of evolutions are required <strong>without</strong> incrementing the major version.</p>
<p>When <code>#[non_exhaustive]</code> is applied to <code>enum</code>s, it forces clients to handle a wildcard variant. If there is no sensible action to take in this case, this may lead to awkward code and code paths that are only executed in extremely rare circumstances. If a client decides to <code>panic!()</code> in this scenario, it may have been better to expose this error at compile time. In fact, <code>#[non_exhaustive]</code> forces clients to handle the “Something else” case; there is rarely a sensible action to take in this scenario.</p>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md">RFC introducing #[non_exhaustive] attribute for enums and structs</a></li>
</ul>
<footer id="last-change-17">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="easy-doc-initialization"><a class="header" href="#easy-doc-initialization">Easy doc initialization</a></h1>
<h2 id="description-14"><a class="header" href="#description-14">Description</a></h2>
<p>If a struct takes significant effort to initialize when writing docs, it can be quicker to wrap your example with a helper function which takes the struct as an argument.</p>
<h2 id="motivation-6"><a class="header" href="#motivation-6">Motivation</a></h2>
<p>Sometimes there is a struct with multiple or complicated parameters and several methods. Each of these methods should have examples.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">struct Connection {
    name: String,
    stream: TcpStream,
}

impl Connection {
    /// Sends a request over the connection.
    ///
    /// # Example
    /// ```no_run
    /// # // Boilerplate are required to get an example working.
    /// # let stream = TcpStream::connect("127.0.0.1:34254");
    /// # let connection = Connection { name: "foo".to_owned(), stream };
    /// # let request = Request::new("RequestId", RequestType::Get, "payload");
    /// let response = connection.send_request(request);
    /// assert!(response.is_ok());
    /// ```
    fn send_request(&amp;self, request: Request) -&gt; Result&lt;Status, SendErr&gt; {
        // ...
    }

    /// Oh no, all that boilerplate needs to be repeated here!
    fn check_status(&amp;self) -&gt; Status {
        // ...
    }
}</code></pre>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<p>Instead of typing all of this boilerplate to create a <code>Connection</code> and <code>Request</code>, it is easier to just create a wrapping helper function which takes them as arguments:</p>
<pre><code class="language-rust ignore">struct Connection {
    name: String,
    stream: TcpStream,
}

impl Connection {
    /// Sends a request over the connection.
    ///
    /// # Example
    /// ```
    /// # fn call_send(connection: Connection, request: Request) {
    /// let response = connection.send_request(request);
    /// assert!(response.is_ok());
    /// # }
    /// ```
    fn send_request(&amp;self, request: Request) -&gt; Result&lt;Status, SendErr&gt; {
        // ...
    }
}</code></pre>
<p><strong>Note</strong> in the above example the line <code>assert!(response.is_ok());</code> will not actually run while testing because it is inside a function which is never invoked.</p>
<h2 id="advantages-9"><a class="header" href="#advantages-9">Advantages</a></h2>
<p>This is much more concise and avoids repetitive code in examples.</p>
<h2 id="disadvantages-10"><a class="header" href="#disadvantages-10">Disadvantages</a></h2>
<p>As example is in a function, the code will not be tested. Though it will still be checked to make sure it compiles when running a <code>cargo test</code>. So this pattern is most useful when you need <code>no_run</code>. With this, you do not need to add <code>no_run</code>.</p>
<h2 id="discussion-5"><a class="header" href="#discussion-5">Discussion</a></h2>
<p>If assertions are not required this pattern works well.</p>
<p>If they are, an alternative can be to create a public method to create a helper instance which is annotated with <code>#[doc(hidden)]</code> (so that users won’t see it). Then this method can be called inside of rustdoc because it is part of the crate’s public API.</p>
<footer id="last-change-18">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="temporary-mutability"><a class="header" href="#temporary-mutability">Temporary mutability</a></h1>
<h2 id="description-15"><a class="header" href="#description-15">Description</a></h2>
<p>Often it is necessary to prepare and process some data, but after that data are only inspected and never modified. The intention can be made explicit by redefining the mutable variable as immutable.</p>
<p>It can be done either by processing data within a nested block or by redefining the variable.</p>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<p>Say, vector must be sorted before usage.</p>
<p>Using nested block:</p>
<pre><code class="language-rust ignore">let data = {
    let mut data = get_vec();
    data.sort();
    data
};

// Here `data` is immutable.</code></pre>
<p>Using variable rebinding:</p>
<pre><code class="language-rust ignore">let mut data = get_vec();
data.sort();
let data = data;

// Here `data` is immutable.</code></pre>
<h2 id="advantages-10"><a class="header" href="#advantages-10">Advantages</a></h2>
<p>Compiler ensures that you don’t accidentally mutate data after some point.</p>
<h2 id="disadvantages-11"><a class="header" href="#disadvantages-11">Disadvantages</a></h2>
<p>Nested block requires additional indentation of block body. One more line to return data from block or redefine variable.</p>
<footer id="last-change-19">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="return-consumed-argument-on-error"><a class="header" href="#return-consumed-argument-on-error">Return consumed argument on error</a></h1>
<h2 id="description-16"><a class="header" href="#description-16">Description</a></h2>
<p>If a fallible function consumes (moves) an argument, return that argument back inside an error.</p>
<h2 id="example-11"><a class="header" href="#example-11">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024">pub fn send(value: String) -&gt; Result&lt;(), SendError&gt; {
    println!("using {value} in a meaningful way");
    // Simulate non-deterministic fallible action.
    use std::time::SystemTime;
    let period = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap();
    if period.subsec_nanos() % 2 == 1 {
        Ok(())
    } else {
        Err(SendError(value))
    }
}

pub struct SendError(String);

fn main() {
    let mut value = "imagine this is very long string".to_string();

    let success = 's: {
        // Try to send value two times.
        for _ in 0..2 {
            value = match send(value) {
                Ok(()) =&gt; break 's true,
                Err(SendError(value)) =&gt; value,
            }
        }
        false
    };

    println!("success: {success}");
}</code></pre>
<h2 id="motivation-7"><a class="header" href="#motivation-7">Motivation</a></h2>
<p>In case of error you may want to try some alternative way or to retry action in case of non-deterministic function. But if the argument is always consumed, you are forced to clone it on every call, which is not very efficient.</p>
<p>The standard library uses this approach in e.g. <code>String::from_utf8</code> method. When given a vector that doesn’t contain valid UTF-8, a <code>FromUtf8Error</code> is returned. You can get original vector back using <code>FromUtf8Error::into_bytes</code> method.</p>
<h2 id="advantages-11"><a class="header" href="#advantages-11">Advantages</a></h2>
<p>Better performance because of moving arguments whenever possible.</p>
<h2 id="disadvantages-12"><a class="header" href="#disadvantages-12">Disadvantages</a></h2>
<p>Slightly more complex error types.</p>
<footer id="last-change-20">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-patterns-1"><a class="header" href="#design-patterns-1">Design Patterns</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Software_design_pattern">Design patterns</a> are “general reusable solutions to a commonly occurring problem within a given context in software design”. Design patterns are a great way to describe the culture of a programming language. Design patterns are very language-specific - what is a pattern in one language may be unnecessary in another due to a language feature, or impossible to express due to a missing feature.</p>
<p>If overused, design patterns can add unnecessary complexity to programs. However, they are a great way to share intermediate and advanced level knowledge about a programming language.</p>
<h2 id="design-patterns-in-rust-1"><a class="header" href="#design-patterns-in-rust-1">Design patterns in Rust</a></h2>
<p>Rust has many unique features. These features give us great benefit by removing whole classes of problems. Some of them are also patterns that are <em>unique</em> to Rust.</p>
<h2 id="yagni"><a class="header" href="#yagni">YAGNI</a></h2>
<p>YAGNI is an acronym that stands for <code>You Aren't Going to Need It</code>. It’s a vital software design principle to apply as you write code.</p>
<blockquote>
<p>The best code I ever wrote was code I never wrote.</p>
</blockquote>
<p>If we apply YAGNI to design patterns, we see that the features of Rust allow us to throw out many patterns. For instance, there is no need for the <a href="https://en.wikipedia.org/wiki/Strategy_pattern">strategy pattern</a> in Rust because we can just use <a href="https://doc.rust-lang.org/book/traits.html">traits</a>.</p>
<footer id="last-change-21">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="behavioural-patterns"><a class="header" href="#behavioural-patterns">Behavioural Patterns</a></h1>
<p>From <a href="https://en.wikipedia.org/wiki/Behavioral_pattern">Wikipedia</a>:</p>
<blockquote>
<p>Design patterns that identify common communication patterns among objects. By doing so, these patterns increase flexibility in carrying out communication.</p>
</blockquote>
<footer id="last-change-22">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="command"><a class="header" href="#command">Command</a></h1>
<h2 id="description-17"><a class="header" href="#description-17">Description</a></h2>
<p>The basic idea of the Command pattern is to separate out actions into its own objects and pass them as parameters.</p>
<h2 id="motivation-8"><a class="header" href="#motivation-8">Motivation</a></h2>
<p>Suppose we have a sequence of actions or transactions encapsulated as objects. We want these actions or commands to be executed or invoked in some order later at different time. These commands may also be triggered as a result of some event. For example, when a user pushes a button, or on arrival of a data packet. In addition, these commands might be undoable. This may come in useful for operations of an editor. We might want to store logs of executed commands so that we could reapply the changes later if the system crashes.</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<p>Define two database operations <code>create table</code> and <code>add field</code>. Each of these operations is a command which knows how to undo the command, e.g., <code>drop table</code> and <code>remove field</code>. When a user invokes a database migration operation then each command is executed in the defined order, and when the user invokes the rollback operation then the whole set of commands is invoked in reverse order.</p>
<h2 id="approach-using-trait-objects"><a class="header" href="#approach-using-trait-objects">Approach: Using trait objects</a></h2>
<p>We define a common trait which encapsulates our command with two operations <code>execute</code> and <code>rollback</code>. All command <code>structs</code> must implement this trait.</p>
<pre class="playground"><code class="language-rust edition2024">pub trait Migration {
    fn execute(&amp;self) -&gt; &amp;str;
    fn rollback(&amp;self) -&gt; &amp;str;
}

pub struct CreateTable;
impl Migration for CreateTable {
    fn execute(&amp;self) -&gt; &amp;str {
        "create table"
    }
    fn rollback(&amp;self) -&gt; &amp;str {
        "drop table"
    }
}

pub struct AddField;
impl Migration for AddField {
    fn execute(&amp;self) -&gt; &amp;str {
        "add field"
    }
    fn rollback(&amp;self) -&gt; &amp;str {
        "remove field"
    }
}

struct Schema {
    commands: Vec&lt;Box&lt;dyn Migration&gt;&gt;,
}

impl Schema {
    fn new() -&gt; Self {
        Self { commands: vec![] }
    }

    fn add_migration(&amp;mut self, cmd: Box&lt;dyn Migration&gt;) {
        self.commands.push(cmd);
    }

    fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.commands.iter().map(|cmd| cmd.execute()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.commands
            .iter()
            .rev() // reverse iterator's direction
            .map(|cmd| cmd.rollback())
            .collect()
    }
}

fn main() {
    let mut schema = Schema::new();

    let cmd = Box::new(CreateTable);
    schema.add_migration(cmd);
    let cmd = Box::new(AddField);
    schema.add_migration(cmd);

    assert_eq!(vec!["create table", "add field"], schema.execute());
    assert_eq!(vec!["remove field", "drop table"], schema.rollback());
}</code></pre>
<h2 id="approach-using-function-pointers"><a class="header" href="#approach-using-function-pointers">Approach: Using function pointers</a></h2>
<p>We could follow another approach by creating each individual command as a different function and store function pointers to invoke these functions later at a different time. Since function pointers implement all three traits <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> we could as well pass and store closures instead of function pointers.</p>
<pre class="playground"><code class="language-rust edition2024">type FnPtr = fn() -&gt; String;
struct Command {
    execute: FnPtr,
    rollback: FnPtr,
}

struct Schema {
    commands: Vec&lt;Command&gt;,
}

impl Schema {
    fn new() -&gt; Self {
        Self { commands: vec![] }
    }
    fn add_migration(&amp;mut self, execute: FnPtr, rollback: FnPtr) {
        self.commands.push(Command { execute, rollback });
    }
    fn execute(&amp;self) -&gt; Vec&lt;String&gt; {
        self.commands.iter().map(|cmd| (cmd.execute)()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;String&gt; {
        self.commands
            .iter()
            .rev()
            .map(|cmd| (cmd.rollback)())
            .collect()
    }
}

fn add_field() -&gt; String {
    "add field".to_string()
}

fn remove_field() -&gt; String {
    "remove field".to_string()
}

fn main() {
    let mut schema = Schema::new();
    schema.add_migration(|| "create table".to_string(), || "drop table".to_string());
    schema.add_migration(add_field, remove_field);
    assert_eq!(vec!["create table", "add field"], schema.execute());
    assert_eq!(vec!["remove field", "drop table"], schema.rollback());
}</code></pre>
<h2 id="approach-using-fn-trait-objects"><a class="header" href="#approach-using-fn-trait-objects">Approach: Using <code>Fn</code> trait objects</a></h2>
<p>Finally, instead of defining a common command trait we could store each command implementing the <code>Fn</code> trait separately in vectors.</p>
<pre class="playground"><code class="language-rust edition2024">type Migration&lt;'a&gt; = Box&lt;dyn Fn() -&gt; &amp;'a str&gt;;

struct Schema&lt;'a&gt; {
    executes: Vec&lt;Migration&lt;'a&gt;&gt;,
    rollbacks: Vec&lt;Migration&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; Schema&lt;'a&gt; {
    fn new() -&gt; Self {
        Self {
            executes: vec![],
            rollbacks: vec![],
        }
    }
    fn add_migration&lt;E, R&gt;(&amp;mut self, execute: E, rollback: R)
    where
        E: Fn() -&gt; &amp;'a str + 'static,
        R: Fn() -&gt; &amp;'a str + 'static,
    {
        self.executes.push(Box::new(execute));
        self.rollbacks.push(Box::new(rollback));
    }
    fn execute(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.executes.iter().map(|cmd| cmd()).collect()
    }
    fn rollback(&amp;self) -&gt; Vec&lt;&amp;str&gt; {
        self.rollbacks.iter().rev().map(|cmd| cmd()).collect()
    }
}

fn add_field() -&gt; &amp;'static str {
    "add field"
}

fn remove_field() -&gt; &amp;'static str {
    "remove field"
}

fn main() {
    let mut schema = Schema::new();
    schema.add_migration(|| "create table", || "drop table");
    schema.add_migration(add_field, remove_field);
    assert_eq!(vec!["create table", "add field"], schema.execute());
    assert_eq!(vec!["remove field", "drop table"], schema.rollback());
}</code></pre>
<h2 id="discussion-6"><a class="header" href="#discussion-6">Discussion</a></h2>
<p>If our commands are small and may be defined as functions or passed as a closure then using function pointers might be preferable since it does not exploit dynamic dispatch. But if our command is a whole struct with a bunch of functions and variables defined as separated module then using trait objects would be more suitable. A case of application can be found in <a href="https://actix.rs/"><code>actix</code></a>, which uses trait objects when it registers a handler function for routes. In case of using <code>Fn</code> trait objects we can create and use commands in the same way as we used in case of function pointers.</p>
<p>As performance, there is always a trade-off between performance and code simplicity and organisation. Static dispatch gives faster performance, while dynamic dispatch provides flexibility when we structure our application.</p>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See also</a></h2>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Command_pattern">Command pattern</a></p>
</li>
<li>
<p><a href="https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust">Another example for the <code>command</code> pattern</a></p>
</li>
</ul>
<footer id="last-change-23">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h1>
<h2 id="description-18"><a class="header" href="#description-18">Description</a></h2>
<p>If a problem occurs very often and requires long and repetitive steps to solve it, then the problem instances might be expressed in a simple language and an interpreter object could solve it by interpreting the sentences written in this simple language.</p>
<p>Basically, for any kind of problems we define:</p>
<ul>
<li>A <a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain specific language</a>,</li>
<li>A grammar for this language,</li>
<li>An interpreter that solves the problem instances.</li>
</ul>
<h2 id="motivation-9"><a class="header" href="#motivation-9">Motivation</a></h2>
<p>Our goal is to translate simple mathematical expressions into postfix expressions (or <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish notation</a>) For simplicity, our expressions consist of ten digits <code>0</code>, …, <code>9</code> and two operations <code>+</code>, <code>-</code>. For example, the expression <code>2 + 4</code> is translated into <code>2 4 +</code>.</p>
<h2 id="context-free-grammar-for-our-problem"><a class="header" href="#context-free-grammar-for-our-problem">Context Free Grammar for our problem</a></h2>
<p>Our task is translating infix expressions into postfix ones. Let’s define a context free grammar for a set of infix expressions over <code>0</code>, …, <code>9</code>, <code>+</code>, and <code>-</code>, where:</p>
<ul>
<li>Terminal symbols: <code>0</code>, <code>...</code>, <code>9</code>, <code>+</code>, <code>-</code></li>
<li>Non-terminal symbols: <code>exp</code>, <code>term</code></li>
<li>Start symbol is <code>exp</code></li>
<li>And the following are production rules</li>
</ul>
<pre><code class="language-ignore">exp -&gt; exp + term
exp -&gt; exp - term
exp -&gt; term
term -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></pre>
<p><strong>NOTE:</strong> This grammar should be further transformed depending on what we are going to do with it. For example, we might need to remove left recursion. For more details please see <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Compilers: Principles,Techniques, and Tools</a> (aka Dragon Book).</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>We simply implement a recursive descent parser. For simplicity’s sake, the code panics when an expression is syntactically wrong (for example <code>2-34</code> or <code>2+5-</code> are wrong according to the grammar definition).</p>
<pre class="playground"><code class="language-rust edition2024">pub struct Interpreter&lt;'a&gt; {
    it: std::str::Chars&lt;'a&gt;,
}

impl&lt;'a&gt; Interpreter&lt;'a&gt; {
    pub fn new(infix: &amp;'a str) -&gt; Self {
        Self { it: infix.chars() }
    }

    fn next_char(&amp;mut self) -&gt; Option&lt;char&gt; {
        self.it.next()
    }

    pub fn interpret(&amp;mut self, out: &amp;mut String) {
        self.term(out);

        while let Some(op) = self.next_char() {
            if op == '+' || op == '-' {
                self.term(out);
                out.push(op);
            } else {
                panic!("Unexpected symbol '{op}'");
            }
        }
    }

    fn term(&amp;mut self, out: &amp;mut String) {
        match self.next_char() {
            Some(ch) if ch.is_digit(10) =&gt; out.push(ch),
            Some(ch) =&gt; panic!("Unexpected symbol '{ch}'"),
            None =&gt; panic!("Unexpected end of string"),
        }
    }
}

pub fn main() {
    let mut intr = Interpreter::new("2+3");
    let mut postfix = String::new();
    intr.interpret(&amp;mut postfix);
    assert_eq!(postfix, "23+");

    intr = Interpreter::new("1-2+3-4");
    postfix.clear();
    intr.interpret(&amp;mut postfix);
    assert_eq!(postfix, "12-3+4-");
}</code></pre>
<h2 id="discussion-7"><a class="header" href="#discussion-7">Discussion</a></h2>
<p>There may be a wrong perception that the Interpreter design pattern is about design grammars for formal languages and implementation of parsers for these grammars. In fact, this pattern is about expressing problem instances in a more specific way and implementing functions/classes/structs that solve these problem instances. Rust language has <code>macro_rules!</code> that allow us to define special syntax and rules on how to expand this syntax into source code.</p>
<p>In the following example we create a simple <code>macro_rules!</code> that computes <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean length</a> of <code>n</code> dimensional vectors. Writing <code>norm!(x,1,2)</code> might be easier to express and more efficient than packing <code>x,1,2</code> into a <code>Vec</code> and calling a function computing the length.</p>
<pre class="playground"><code class="language-rust edition2024">macro_rules! norm {
    ($($element:expr),*) =&gt; {
        {
            let mut n = 0.0;
            $(
                n += ($element as f64)*($element as f64);
            )*
            n.sqrt()
        }
    };
}

fn main() {
    let x = -3f64;
    let y = 4f64;

    assert_eq!(3f64, norm!(x));
    assert_eq!(5f64, norm!(x, y));
    assert_eq!(0f64, norm!(0, 0, 0));
    assert_eq!(1f64, norm!(0.5, -0.5, 0.5, -0.5));
}</code></pre>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See also</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interpreter_pattern">Interpreter pattern</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context free grammar</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/macros.html">macro_rules!</a></li>
</ul>
<footer id="last-change-24">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="newtype"><a class="header" href="#newtype">Newtype</a></h1>
<p>What if in some cases we want a type to behave similar to another type or enforce some behaviour at compile time when using only type aliases would not be enough?</p>
<p>For example, if we want to create a custom <code>Display</code> implementation for <code>String</code> due to security considerations (e.g. passwords).</p>
<p>For such cases we could use the <code>Newtype</code> pattern to provide <strong>type safety</strong> and <strong>encapsulation</strong>.</p>
<h2 id="description-19"><a class="header" href="#description-19">Description</a></h2>
<p>Use a tuple struct with a single field to make an opaque wrapper for a type. This creates a new type, rather than an alias to a type (<code>type</code> items).</p>
<h2 id="example-13"><a class="header" href="#example-13">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024">use std::fmt::Display;

// Create Newtype Password to override the Display trait for String
struct Password(String);

impl Display for Password {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "****************")
    }
}

fn main() {
    let unsecured_password: String = "ThisIsMyPassword".to_string();
    let secured_password: Password = Password(unsecured_password.clone());
    println!("unsecured_password: {unsecured_password}");
    println!("secured_password: {secured_password}");
}</code></pre>
<pre><code class="language-shell">unsecured_password: ThisIsMyPassword
secured_password: ****************
</code></pre>
<h2 id="motivation-10"><a class="header" href="#motivation-10">Motivation</a></h2>
<p>The primary motivation for newtypes is abstraction. It allows you to share implementation details between types while precisely controlling the interface. By using a newtype rather than exposing the implementation type as part of an API, it allows you to change implementation backwards compatibly.</p>
<p>Newtypes can be used for distinguishing units, e.g., wrapping <code>f64</code> to give distinguishable <code>Miles</code> and <code>Kilometres</code>.</p>
<h2 id="advantages-12"><a class="header" href="#advantages-12">Advantages</a></h2>
<p>The wrapped and wrapper types are not type compatible (as opposed to using <code>type</code>), so users of the newtype will never ‘confuse’ the wrapped and wrapper types.</p>
<p>Newtypes are a zero-cost abstraction - there is no runtime overhead.</p>
<p>The privacy system ensures that users cannot access the wrapped type (if the field is private, which it is by default).</p>
<h2 id="disadvantages-13"><a class="header" href="#disadvantages-13">Disadvantages</a></h2>
<p>The downside of newtypes (especially compared with type aliases), is that there is no special language support. This means there can be <em>a lot</em> of boilerplate. You need a ‘pass through’ method for every method you want to expose on the wrapped type, and an impl for every trait you want to also be implemented for the wrapper type.</p>
<h2 id="discussion-8"><a class="header" href="#discussion-8">Discussion</a></h2>
<p>Newtypes are very common in Rust code. Abstraction or representing units are the most common uses, but they can be used for other reasons:</p>
<ul>
<li>restricting functionality (reduce the functions exposed or traits implemented),</li>
<li>making a type with copy semantics have move semantics,</li>
<li>abstraction by providing a more concrete type and thus hiding internal types, e.g.,</li>
</ul>
<pre><code class="language-rust ignore">pub struct Foo(Bar&lt;T1, T2&gt;);</code></pre>
<p>Here, <code>Bar</code> might be some public, generic type and <code>T1</code> and <code>T2</code> are some internal types. Users of our module shouldn’t know that we implement <code>Foo</code> by using a <code>Bar</code>, but what we’re really hiding here is the types <code>T1</code> and <code>T2</code>, and how they are used with <code>Bar</code>.</p>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See also</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html?highlight=newtype#using-the-newtype-pattern-for-type-safety-and-abstraction">Advanced Types in the book</a></li>
<li><a href="https://wiki.haskell.org/Newtype">Newtypes in Haskell</a></li>
<li><a href="https://doc.rust-lang.org/stable/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">Type aliases</a></li>
<li><a href="https://crates.io/crates/derive_more">derive_more</a>, a crate for deriving many builtin traits on newtypes.</li>
<li><a href="https://web.archive.org/web/20230519162111/https://www.worthe-it.co.za/blog/2020-10-31-newtype-pattern-in-rust.html">The Newtype Pattern In Rust</a></li>
</ul>
<footer id="last-change-25">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="raii-with-guards"><a class="header" href="#raii-with-guards">RAII with guards</a></h1>
<h2 id="description-20"><a class="header" href="#description-20">Description</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> stands for “Resource Acquisition is Initialisation” which is a terrible name. The essence of the pattern is that resource initialisation is done in the constructor of an object and finalisation in the destructor. This pattern is extended in Rust by using a RAII object as a guard of some resource and relying on the type system to ensure that access is always mediated by the guard object.</p>
<h2 id="example-14"><a class="header" href="#example-14">Example</a></h2>
<p>Mutex guards are the classic example of this pattern from the std library (this is a simplified version of the real implementation):</p>
<pre><code class="language-rust ignore">use std::ops::Deref;

struct Foo {}

struct Mutex&lt;T&gt; {
    // We keep a reference to our data: T here.
    //..
}

struct MutexGuard&lt;'a, T: 'a&gt; {
    data: &amp;'a T,
    //..
}

// Locking the mutex is explicit.
impl&lt;T&gt; Mutex&lt;T&gt; {
    fn lock(&amp;self) -&gt; MutexGuard&lt;T&gt; {
        // Lock the underlying OS mutex.
        //..

        // MutexGuard keeps a reference to self
        MutexGuard {
            data: self,
            //..
        }
    }
}

// Destructor for unlocking the mutex.
impl&lt;'a, T&gt; Drop for MutexGuard&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // Unlock the underlying OS mutex.
        //..
    }
}

// Implementing Deref means we can treat MutexGuard like a pointer to T.
impl&lt;'a, T&gt; Deref for MutexGuard&lt;'a, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        self.data
    }
}

fn baz(x: Mutex&lt;Foo&gt;) {
    let xx = x.lock();
    xx.foo(); // foo is a method on Foo.
              // The borrow checker ensures we can't store a reference to the underlying
              // Foo which will outlive the guard xx.

    // x is unlocked when we exit this function and xx's destructor is executed.
}</code></pre>
<h2 id="motivation-11"><a class="header" href="#motivation-11">Motivation</a></h2>
<p>Where a resource must be finalised after use, RAII can be used to do this finalisation. If it is an error to access that resource after finalisation, then this pattern can be used to prevent such errors.</p>
<h2 id="advantages-13"><a class="header" href="#advantages-13">Advantages</a></h2>
<p>Prevents errors where a resource is not finalised and where a resource is used after finalisation.</p>
<h2 id="discussion-9"><a class="header" href="#discussion-9">Discussion</a></h2>
<p>RAII is a useful pattern for ensuring resources are properly deallocated or finalised. We can make use of the borrow checker in Rust to statically prevent errors stemming from using resources after finalisation takes place.</p>
<p>The core aim of the borrow checker is to ensure that references to data do not outlive that data. The RAII guard pattern works because the guard object contains a reference to the underlying resource and only exposes such references. Rust ensures that the guard cannot outlive the underlying resource and that references to the resource mediated by the guard cannot outlive the guard. To see how this works it is helpful to examine the signature of <code>deref</code> without lifetime elision:</p>
<pre><code class="language-rust ignore">fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a T {
    //..
}</code></pre>
<p>The returned reference to the resource has the same lifetime as <code>self</code> (<code>'a</code>). The borrow checker therefore ensures that the lifetime of the reference to <code>T</code> is shorter than the lifetime of <code>self</code>.</p>
<p>Note that implementing <code>Deref</code> is not a core part of this pattern, it only makes using the guard object more ergonomic. Implementing a <code>get</code> method on the guard works just as well.</p>
<h2 id="see-also-12"><a class="header" href="#see-also-12">See also</a></h2>
<p><a href="#finalisation-in-destructors">Finalisation in destructors idiom</a></p>
<p>RAII is a common pattern in C++: <a href="http://en.cppreference.com/w/cpp/language/raii">cppreference.com</a>, <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">wikipedia</a>.</p>
<p><a href="https://doc.rust-lang.org/1.0.0/style/ownership/raii.html">Style guide entry</a> (currently just a placeholder).</p>
<footer id="last-change-26">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="strategy-aka-policy"><a class="header" href="#strategy-aka-policy">Strategy (aka Policy)</a></h1>
<h2 id="description-21"><a class="header" href="#description-21">Description</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy design pattern</a> is a technique that enables separation of concerns. It also allows to decouple software modules through <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion</a>.</p>
<p>The basic idea behind the Strategy pattern is that, given an algorithm solving a particular problem, we define only the skeleton of the algorithm at an abstract level, and we separate the specific algorithm’s implementation into different parts.</p>
<p>In this way, a client using the algorithm may choose a specific implementation, while the general algorithm workflow remains the same. In other words, the abstract specification of the class does not depend on the specific implementation of the derived class, but specific implementation must adhere to the abstract specification. This is why we call it “Dependency Inversion”.</p>
<h2 id="motivation-12"><a class="header" href="#motivation-12">Motivation</a></h2>
<p>Imagine we are working on a project that generates reports every month. We need the reports to be generated in different formats (strategies), e.g., in <code>JSON</code> or <code>Plain Text</code> formats. But things vary over time, and we don’t know what kind of requirement we may get in the future. For example, we may need to generate our report in a completely new format, or just modify one of the existing formats.</p>
<h2 id="example-15"><a class="header" href="#example-15">Example</a></h2>
<p>In this example our invariants (or abstractions) are <code>Formatter</code> and <code>Report</code>, while <code>Text</code> and <code>Json</code> are our strategy structs. These strategies have to implement the <code>Formatter</code> trait.</p>
<pre class="playground"><code class="language-rust edition2024">use std::collections::HashMap;

type Data = HashMap&lt;String, u32&gt;;

trait Formatter {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String);
}

struct Report;

impl Report {
    // Write should be used but we kept it as String to ignore error handling
    fn generate&lt;T: Formatter&gt;(g: T, s: &amp;mut String) {
        // backend operations...
        let mut data = HashMap::new();
        data.insert("one".to_string(), 1);
        data.insert("two".to_string(), 2);
        // generate report
        g.format(&amp;data, s);
    }
}

struct Text;
impl Formatter for Text {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String) {
        for (k, v) in data {
            let entry = format!("{k} {v}\n");
            buf.push_str(&amp;entry);
        }
    }
}

struct Json;
impl Formatter for Json {
    fn format(&amp;self, data: &amp;Data, buf: &amp;mut String) {
        buf.push('[');
        for (k, v) in data.into_iter() {
            let entry = format!(r#"{{"{}":"{}"}}"#, k, v);
            buf.push_str(&amp;entry);
            buf.push(',');
        }
        if !data.is_empty() {
            buf.pop(); // remove extra , at the end
        }
        buf.push(']');
    }
}

fn main() {
    let mut s = String::from("");
    Report::generate(Text, &amp;mut s);
    assert!(s.contains("one 1"));
    assert!(s.contains("two 2"));

    s.clear(); // reuse the same buffer
    Report::generate(Json, &amp;mut s);
    assert!(s.contains(r#"{"one":"1"}"#));
    assert!(s.contains(r#"{"two":"2"}"#));
}</code></pre>
<h2 id="advantages-14"><a class="header" href="#advantages-14">Advantages</a></h2>
<p>The main advantage is separation of concerns. For example, in this case <code>Report</code> does not know anything about specific implementations of <code>Json</code> and <code>Text</code>, whereas the output implementations does not care about how data is preprocessed, stored, and fetched. The only thing they have to know is a specific trait to implement and its method defining the concrete algorithm implementation processing the result, i.e., <code>Formatter</code> and <code>format(...)</code>.</p>
<h2 id="disadvantages-14"><a class="header" href="#disadvantages-14">Disadvantages</a></h2>
<p>For each strategy there must be implemented at least one module, so number of modules increases with number of strategies. If there are many strategies to choose from then users have to know how strategies differ from one another.</p>
<h2 id="discussion-10"><a class="header" href="#discussion-10">Discussion</a></h2>
<p>In the previous example all strategies are implemented in a single file. Ways of providing different strategies includes:</p>
<ul>
<li>All in one file (as shown in this example, similar to being separated as modules)</li>
<li>Separated as modules, E.g. <code>formatter::json</code> module, <code>formatter::text</code> module</li>
<li>Use compiler feature flags, E.g. <code>json</code> feature, <code>text</code> feature</li>
<li>Separated as crates, E.g. <code>json</code> crate, <code>text</code> crate</li>
</ul>
<p>Serde crate is a good example of the <code>Strategy</code> pattern in action. Serde allows <a href="https://serde.rs/custom-serialization.html">full customization</a> of the serialization behavior by manually implementing <code>Serialize</code> and <code>Deserialize</code> traits for our type. For example, we could easily swap <code>serde_json</code> with <code>serde_cbor</code> since they expose similar methods. Having this makes the helper crate <code>serde_transcode</code> much more useful and ergonomic.</p>
<p>However, we don’t need to use traits in order to design this pattern in Rust.</p>
<p>The following toy example demonstrates the idea of the Strategy pattern using Rust <code>closures</code>:</p>
<pre class="playground"><code class="language-rust edition2024">struct Adder;
impl Adder {
    pub fn add&lt;F&gt;(x: u8, y: u8, f: F) -&gt; u8
    where
        F: Fn(u8, u8) -&gt; u8,
    {
        f(x, y)
    }
}

fn main() {
    let arith_adder = |x, y| x + y;
    let bool_adder = |x, y| {
        if x == 1 || y == 1 {
            1
        } else {
            0
        }
    };
    let custom_adder = |x, y| 2 * x + y;

    assert_eq!(9, Adder::add(4, 5, arith_adder));
    assert_eq!(0, Adder::add(0, 0, bool_adder));
    assert_eq!(5, Adder::add(1, 3, custom_adder));
}</code></pre>
<p>In fact, Rust already uses this idea for <code>Options</code>’s <code>map</code> method:</p>
<pre class="playground"><code class="language-rust edition2024">fn main() {
    let val = Some("Rust");

    let len_strategy = |s: &amp;str| s.len();
    assert_eq!(4, val.map(len_strategy).unwrap());

    let first_byte_strategy = |s: &amp;str| s.bytes().next().unwrap();
    assert_eq!(82, val.map(first_byte_strategy).unwrap());
}</code></pre>
<h2 id="see-also-13"><a class="header" href="#see-also-13">See also</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy Pattern</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a></li>
<li><a href="https://en.wikipedia.org/wiki/Modern_C++_Design#Policy-based_design">Policy Based Design</a></li>
<li><a href="https://web.archive.org/web/20231003171500/https://robamu.github.io/posts/rust-strategy-pattern/">Implementing a TCP server for Space Applications in Rust using the Strategy Pattern</a></li>
</ul>
<footer id="last-change-27">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="visitor"><a class="header" href="#visitor">Visitor</a></h1>
<h2 id="description-22"><a class="header" href="#description-22">Description</a></h2>
<p>A visitor encapsulates an algorithm that operates over a heterogeneous collection of objects. It allows multiple different algorithms to be written over the same data without having to modify the data (or their primary behaviour).</p>
<p>Furthermore, the visitor pattern allows separating the traversal of a collection of objects from the operations performed on each object.</p>
<h2 id="example-16"><a class="header" href="#example-16">Example</a></h2>
<pre><code class="language-rust ignore">// The data we will visit
mod ast {
    pub enum Stmt {
        Expr(Expr),
        Let(Name, Expr),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract visitor
mod visit {
    use ast::*;

    pub trait Visitor&lt;T&gt; {
        fn visit_name(&amp;mut self, n: &amp;Name) -&gt; T;
        fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; T;
        fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; T;
    }
}

use ast::*;
use visit::*;

// An example concrete implementation - walks the AST interpreting it as code.
struct Interpreter;
impl Visitor&lt;i64&gt; for Interpreter {
    fn visit_name(&amp;mut self, n: &amp;Name) -&gt; i64 {
        panic!()
    }
    fn visit_stmt(&amp;mut self, s: &amp;Stmt) -&gt; i64 {
        match *s {
            Stmt::Expr(ref e) =&gt; self.visit_expr(e),
            Stmt::Let(..) =&gt; unimplemented!(),
        }
    }

    fn visit_expr(&amp;mut self, e: &amp;Expr) -&gt; i64 {
        match *e {
            Expr::IntLit(n) =&gt; n,
            Expr::Add(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) + self.visit_expr(rhs),
            Expr::Sub(ref lhs, ref rhs) =&gt; self.visit_expr(lhs) - self.visit_expr(rhs),
        }
    }
}</code></pre>
<p>One could implement further visitors, for example a type checker, without having to modify the AST data.</p>
<h2 id="motivation-13"><a class="header" href="#motivation-13">Motivation</a></h2>
<p>The visitor pattern is useful anywhere that you want to apply an algorithm to heterogeneous data. If data is homogeneous, you can use an iterator-like pattern. Using a visitor object (rather than a functional approach) allows the visitor to be stateful and thus communicate information between nodes.</p>
<h2 id="discussion-11"><a class="header" href="#discussion-11">Discussion</a></h2>
<p>It is common for the <code>visit_*</code> methods to return void (as opposed to in the example). In that case it is possible to factor out the traversal code and share it between algorithms (and also to provide noop default methods). In Rust, the common way to do this is to provide <code>walk_*</code> functions for each datum. For example,</p>
<pre><code class="language-rust ignore">pub fn walk_expr(visitor: &amp;mut Visitor, e: &amp;Expr) {
    match *e {
        Expr::IntLit(_) =&gt; {}
        Expr::Add(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
        Expr::Sub(ref lhs, ref rhs) =&gt; {
            visitor.visit_expr(lhs);
            visitor.visit_expr(rhs);
        }
    }
}</code></pre>
<p>In other languages (e.g., Java) it is common for data to have an <code>accept</code> method which performs the same duty.</p>
<h2 id="see-also-14"><a class="header" href="#see-also-14">See also</a></h2>
<p>The visitor pattern is a common pattern in most OO languages.</p>
<p><a href="https://en.wikipedia.org/wiki/Visitor_pattern">Wikipedia article</a></p>
<p>The <a href="#fold">fold</a> pattern is similar to visitor but produces a new version of the visited data structure.</p>
<footer id="last-change-28">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="creational-patterns"><a class="header" href="#creational-patterns">Creational Patterns</a></h1>
<p>From <a href="https://en.wikipedia.org/wiki/Creational_pattern">Wikipedia</a>:</p>
<blockquote>
<p>Design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or in added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p>
</blockquote>
<footer id="last-change-29">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="builder"><a class="header" href="#builder">Builder</a></h1>
<h2 id="description-23"><a class="header" href="#description-23">Description</a></h2>
<p>Construct an object with calls to a builder helper.</p>
<h2 id="example-17"><a class="header" href="#example-17">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

impl Foo {
    // This method will help users to discover the builder
    pub fn builder() -&gt; FooBuilder {
        FooBuilder::default()
    }
}

#[derive(Default)]
pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from("X"),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from("Y"),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from("Y")).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}</span></code></pre>
<h2 id="motivation-14"><a class="header" href="#motivation-14">Motivation</a></h2>
<p>Useful when you would otherwise require many constructors or where construction has side effects.</p>
<h2 id="advantages-15"><a class="header" href="#advantages-15">Advantages</a></h2>
<p>Separates methods for building from other methods.</p>
<p>Prevents proliferation of constructors.</p>
<p>Can be used for one-liner initialisation as well as more complex construction.</p>
<p>When you add new fields to the target struct, you can update the builder to leave client code backwards compatible.</p>
<h2 id="disadvantages-15"><a class="header" href="#disadvantages-15">Disadvantages</a></h2>
<p>More complex than creating a struct object directly, or a simple constructor function.</p>
<h2 id="discussion-12"><a class="header" href="#discussion-12">Discussion</a></h2>
<p>This pattern is seen more frequently in Rust (and for simpler objects) than in many other languages because Rust lacks overloading and default values for function parameters. Since you can only have a single method with a given name, having multiple constructors is less nice in Rust than in C++, Java, or others.</p>
<p>This pattern is often used where the builder object is useful in its own right, rather than being just a builder. For example, see <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a> is a builder for <a href="https://doc.rust-lang.org/std/process/struct.Child.html"><code>Child</code></a> (a process). In these cases, the <code>T</code> and <code>TBuilder</code> naming pattern is not used.</p>
<p>The example takes and returns the builder by value. It is often more ergonomic (and more efficient) to take and return the builder as a mutable reference. The borrow checker makes this work naturally. This approach has the advantage that one can write code like</p>
<pre><code class="language-rust ignore">let mut fb = FooBuilder::new();
fb.a();
fb.b();
let f = fb.build();</code></pre>
<p>as well as the <code>FooBuilder::new().a().b().build()</code> style.</p>
<h2 id="see-also-15"><a class="header" href="#see-also-15">See also</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20210104103100/https://doc.rust-lang.org/1.12.0/style/ownership/builders.html">Description in the style guide</a></li>
<li><a href="https://crates.io/crates/derive_builder">derive_builder</a>, a crate for automatically implementing this pattern while avoiding the boilerplate.</li>
<li><a href="#constructors">Constructor pattern</a> for when construction is simpler.</li>
<li><a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder pattern (wikipedia)</a></li>
<li><a href="https://web.archive.org/web/20210104103000/https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder">Construction of complex values</a></li>
</ul>
<footer id="last-change-30">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="fold"><a class="header" href="#fold">Fold</a></h1>
<h2 id="description-24"><a class="header" href="#description-24">Description</a></h2>
<p>Run an algorithm over each item in a collection of data to create a new item, thus creating a whole new collection.</p>
<p>The etymology here is unclear to me. The terms ‘fold’ and ‘folder’ are used in the Rust compiler, although it appears to me to be more like a map than a fold in the usual sense. See the discussion below for more details.</p>
<h2 id="example-18"><a class="header" href="#example-18">Example</a></h2>
<pre><code class="language-rust ignore">// The data we will fold, a simple AST.
mod ast {
    pub enum Stmt {
        Expr(Box&lt;Expr&gt;),
        Let(Box&lt;Name&gt;, Box&lt;Expr&gt;),
    }

    pub struct Name {
        value: String,
    }

    pub enum Expr {
        IntLit(i64),
        Add(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
        Sub(Box&lt;Expr&gt;, Box&lt;Expr&gt;),
    }
}

// The abstract folder
mod fold {
    use ast::*;

    pub trait Folder {
        // A leaf node just returns the node itself. In some cases, we can do this
        // to inner nodes too.
        fn fold_name(&amp;mut self, n: Box&lt;Name&gt;) -&gt; Box&lt;Name&gt; { n }
        // Create a new inner node by folding its children.
        fn fold_stmt(&amp;mut self, s: Box&lt;Stmt&gt;) -&gt; Box&lt;Stmt&gt; {
            match *s {
                Stmt::Expr(e) =&gt; Box::new(Stmt::Expr(self.fold_expr(e))),
                Stmt::Let(n, e) =&gt; Box::new(Stmt::Let(self.fold_name(n), self.fold_expr(e))),
            }
        }
        fn fold_expr(&amp;mut self, e: Box&lt;Expr&gt;) -&gt; Box&lt;Expr&gt; { ... }
    }
}

use fold::*;
use ast::*;

// An example concrete implementation - renames every name to 'foo'.
struct Renamer;
impl Folder for Renamer {
    fn fold_name(&amp;mut self, n: Box&lt;Name&gt;) -&gt; Box&lt;Name&gt; {
        Box::new(Name { value: "foo".to_owned() })
    }
    // Use the default methods for the other nodes.
}</code></pre>
<p>The result of running the <code>Renamer</code> on an AST is a new AST identical to the old one, but with every name changed to <code>foo</code>. A real life folder might have some state preserved between nodes in the struct itself.</p>
<p>A folder can also be defined to map one data structure to a different (but usually similar) data structure. For example, we could fold an AST into a HIR tree (HIR stands for high-level intermediate representation).</p>
<h2 id="motivation-15"><a class="header" href="#motivation-15">Motivation</a></h2>
<p>It is common to want to map a data structure by performing some operation on each node in the structure. For simple operations on simple data structures, this can be done using <code>Iterator::map</code>. For more complex operations, perhaps where earlier nodes can affect the operation on later nodes, or where iteration over the data structure is non-trivial, using the fold pattern is more appropriate.</p>
<p>Like the visitor pattern, the fold pattern allows us to separate traversal of a data structure from the operations performed to each node.</p>
<h2 id="discussion-13"><a class="header" href="#discussion-13">Discussion</a></h2>
<p>Mapping data structures in this fashion is common in functional languages. In OO languages, it would be more common to mutate the data structure in place. The ‘functional’ approach is common in Rust, mostly due to the preference for immutability. Using fresh data structures, rather than mutating old ones, makes reasoning about the code easier in most circumstances.</p>
<p>The trade-off between efficiency and reusability can be tweaked by changing how nodes are accepted by the <code>fold_*</code> methods.</p>
<p>In the above example we operate on <code>Box</code> pointers. Since these own their data exclusively, the original copy of the data structure cannot be re-used. On the other hand if a node is not changed, reusing it is very efficient.</p>
<p>If we were to operate on borrowed references, the original data structure can be reused; however, a node must be cloned even if unchanged, which can be expensive.</p>
<p>Using a reference counted pointer gives the best of both worlds - we can reuse the original data structure, and we don’t need to clone unchanged nodes. However, they are less ergonomic to use and mean that the data structures cannot be mutable.</p>
<h2 id="see-also-16"><a class="header" href="#see-also-16">See also</a></h2>
<p>Iterators have a <code>fold</code> method, however this folds a data structure into a value, rather than into a new data structure. An iterator’s <code>map</code> is more like this fold pattern.</p>
<p>In other languages, fold is usually used in the sense of Rust’s iterators, rather than this pattern. Some functional languages have powerful constructs for performing flexible maps over data structures.</p>
<p>The <a href="#visitor">visitor</a> pattern is closely related to fold. They share the concept of walking a data structure performing an operation on each node. However, the visitor does not create a new data structure nor consume the old one.</p>
<footer id="last-change-31">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="structural-patterns"><a class="header" href="#structural-patterns">Structural Patterns</a></h1>
<p>From <a href="https://en.wikipedia.org/wiki/Structural_pattern">Wikipedia</a>:</p>
<blockquote>
<p>Design patterns that ease the design by identifying a simple way to realize relationships among entities.</p>
</blockquote>
<footer id="last-change-32">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="struct-decomposition-for-independent-borrowing"><a class="header" href="#struct-decomposition-for-independent-borrowing">Struct decomposition for independent borrowing</a></h1>
<h2 id="description-25"><a class="header" href="#description-25">Description</a></h2>
<p>Sometimes a large struct will cause issues with the borrow checker - although fields can be borrowed independently, sometimes the whole struct ends up being used at once, preventing other uses. A solution might be to decompose the struct into several smaller structs. Then compose these together into the original struct. Then each struct can be borrowed separately and have more flexible behaviour.</p>
<p>This will often lead to a better design in other ways: applying this design pattern often reveals smaller units of functionality.</p>
<h2 id="example-19"><a class="header" href="#example-19">Example</a></h2>
<p>Here is a contrived example of where the borrow checker foils us in our plan to use a struct:</p>
<pre><code class="language-rust ignore">struct Database {
    connection_string: String,
    timeout: u32,
    pool_size: u32,
}

fn print_database(database: &amp;Database) {
    println!("Connection string: {}", database.connection_string);
    println!("Timeout: {}", database.timeout);
    println!("Pool size: {}", database.pool_size);
}

fn main() {
    let mut db = Database {
        connection_string: "initial string".to_string(),
        timeout: 30,
        pool_size: 100,
    };

    let connection_string = &amp;mut db.connection_string;
    print_database(&amp;db);
    *connection_string = "new string".to_string();
}</code></pre>
<p>The compiler throws following errors:</p>
<pre><code class="language-ignore">let connection_string = &amp;mut db.connection_string;
                        ------------------------- mutable borrow occurs here
print_database(&amp;db);
               ^^^ immutable borrow occurs here
*connection_string = "new string".to_string();
------------------ mutable borrow later used here
</code></pre>
<p>We can apply this design pattern and refactor <code>Database</code> into three smaller structs, thus solving the borrow checking issue:</p>
<pre class="playground"><code class="language-rust edition2024">// Database is now composed of three structs - ConnectionString, Timeout and PoolSize.
// Let's decompose it into smaller structs
#[derive(Debug, Clone)]
struct ConnectionString(String);

#[derive(Debug, Clone, Copy)]
struct Timeout(u32);

#[derive(Debug, Clone, Copy)]
struct PoolSize(u32);

// We then compose these smaller structs back into `Database`
struct Database {
    connection_string: ConnectionString,
    timeout: Timeout,
    pool_size: PoolSize,
}

// print_database can then take ConnectionString, Timeout and Poolsize struct instead
fn print_database(connection_str: ConnectionString, timeout: Timeout, pool_size: PoolSize) {
    println!("Connection string: {connection_str:?}");
    println!("Timeout: {timeout:?}");
    println!("Pool size: {pool_size:?}");
}

fn main() {
    // Initialize the Database with the three structs
    let mut db = Database {
        connection_string: ConnectionString("localhost".to_string()),
        timeout: Timeout(30),
        pool_size: PoolSize(100),
    };

    let connection_string = &amp;mut db.connection_string;
    print_database(connection_string.clone(), db.timeout, db.pool_size);
    *connection_string = ConnectionString("new string".to_string());
}</code></pre>
<h2 id="motivation-16"><a class="header" href="#motivation-16">Motivation</a></h2>
<p>This pattern is most useful, when you have a struct that ended up with a lot of fields that you want to borrow independently. Thus having a more flexible behaviour in the end.</p>
<h2 id="advantages-16"><a class="header" href="#advantages-16">Advantages</a></h2>
<p>Decomposition of structs lets you work around limitations in the borrow checker. And it often produces a better design.</p>
<h2 id="disadvantages-16"><a class="header" href="#disadvantages-16">Disadvantages</a></h2>
<p>It can lead to more verbose code. And sometimes, the smaller structs are not good abstractions, and so we end up with a worse design. That is probably a ‘code smell’, indicating that the program should be refactored in some way.</p>
<h2 id="discussion-14"><a class="header" href="#discussion-14">Discussion</a></h2>
<p>This pattern is not required in languages that don’t have a borrow checker, so in that sense is unique to Rust. However, making smaller units of functionality often leads to cleaner code: a widely acknowledged principle of software engineering, independent of the language.</p>
<p>This pattern relies on Rust’s borrow checker to be able to borrow fields independently of each other. In the example, the borrow checker knows that <code>a.b</code> and <code>a.c</code> are distinct and can be borrowed independently, it does not try to borrow all of <code>a</code>, which would make this pattern useless.</p>
<footer id="last-change-33">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="prefer-small-crates"><a class="header" href="#prefer-small-crates">Prefer small crates</a></h1>
<h2 id="description-26"><a class="header" href="#description-26">Description</a></h2>
<p>Prefer small crates that do one thing well.</p>
<p>Cargo and crates.io make it easy to add third-party libraries, much more so than in say C or C++. Moreover, since packages on crates.io cannot be edited or removed after publication, any build that works now should continue to work in the future. We should take advantage of this tooling, and use smaller, more fine-grained dependencies.</p>
<h2 id="advantages-17"><a class="header" href="#advantages-17">Advantages</a></h2>
<ul>
<li>Small crates are easier to understand, and encourage more modular code.</li>
<li>Crates allow for re-using code between projects. For example, the <code>url</code> crate was developed as part of the Servo browser engine, but has since found wide use outside the project.</li>
<li>Since the compilation unit of Rust is the crate, splitting a project into multiple crates can allow more of the code to be built in parallel.</li>
</ul>
<h2 id="disadvantages-17"><a class="header" href="#disadvantages-17">Disadvantages</a></h2>
<ul>
<li>This can lead to “dependency hell”, when a project depends on multiple conflicting versions of a crate at the same time. For example, the <code>url</code> crate has both versions 1.0 and 0.5. Since the <code>Url</code> from <code>url:1.0</code> and the <code>Url</code> from <code>url:0.5</code> are different types, an HTTP client that uses <code>url:0.5</code> would not accept <code>Url</code> values from a web scraper that uses <code>url:1.0</code>.</li>
<li>Packages on crates.io are not curated. A crate may be poorly written, have unhelpful documentation, or be outright malicious.</li>
<li>Two small crates may be less optimized than one large one, since the compiler does not perform link-time optimization (LTO) by default.</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>The <a href="https://crates.io/crates/url"><code>url</code></a> crate provides tools for working with URLs.</p>
<p>The <a href="https://crates.io/crates/num_cpus"><code>num_cpus</code></a> crate provides a function to query the number of CPUs on a machine.</p>
<p>The <a href="https://crates.io/crates/ref_slice"><code>ref_slice</code></a> crate provides functions for converting <code>&amp;T</code> to <code>&amp;[T]</code>. (Historical example)</p>
<h2 id="see-also-17"><a class="header" href="#see-also-17">See also</a></h2>
<ul>
<li><a href="https://crates.io/">crates.io: The Rust community crate host</a></li>
</ul>
<footer id="last-change-34">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="contain-unsafety-in-small-modules"><a class="header" href="#contain-unsafety-in-small-modules">Contain unsafety in small modules</a></h1>
<h2 id="description-27"><a class="header" href="#description-27">Description</a></h2>
<p>If you have <code>unsafe</code> code, create the smallest possible module that can uphold the needed invariants to build a minimal safe interface upon the unsafety. Embed this into a larger module that contains only safe code and presents an ergonomic interface. Note that the outer module can contain unsafe functions and methods that call directly into the unsafe code. Users may use this to gain speed benefits.</p>
<h2 id="advantages-18"><a class="header" href="#advantages-18">Advantages</a></h2>
<ul>
<li>This restricts the unsafe code that must be audited</li>
<li>Writing the outer module is much easier, since you can count on the guarantees of the inner module</li>
</ul>
<h2 id="disadvantages-18"><a class="header" href="#disadvantages-18">Disadvantages</a></h2>
<ul>
<li>Sometimes, it may be hard to find a suitable interface.</li>
<li>The abstraction may introduce inefficiencies.</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<ul>
<li>The <a href="https://docs.rs/toolshed"><code>toolshed</code></a> crate contains its unsafe operations in submodules, presenting a safe interface to users.</li>
<li><code>std</code>’s <code>String</code> class is a wrapper over <code>Vec&lt;u8&gt;</code> with the added invariant that the contents must be valid UTF-8. The operations on <code>String</code> ensure this behavior. However, users have the option of using an <code>unsafe</code> method to create a <code>String</code>, in which case the onus is on them to guarantee the validity of the contents.</li>
</ul>
<h2 id="see-also-18"><a class="header" href="#see-also-18">See also</a></h2>
<ul>
<li><a href="https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html">Ralf Jung’s Blog about invariants in unsafe code</a></li>
</ul>
<footer id="last-change-35">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="use-custom-traits-to-avoid-complex-type-bounds"><a class="header" href="#use-custom-traits-to-avoid-complex-type-bounds">Use custom traits to avoid complex type bounds</a></h1>
<h2 id="description-28"><a class="header" href="#description-28">Description</a></h2>
<p>Trait bounds can become somewhat unwieldy, especially if one of the <code>Fn</code> traits<sup class="footnote-reference" id="fr-fn-traits-1"><a href="#footnote-fn-traits">1</a></sup> is involved and there are specific requirements on the output type. In such cases the introduction of a new trait may help reduce verbosity, eliminate some type parameters and thus increase expressiveness. Such a trait can be accompanied with a generic <code>impl</code> for all types satisfying the original bound.</p>
<h2 id="example-20"><a class="header" href="#example-20">Example</a></h2>
<p>Let’s imagine some sort of monitoring or information gathering system. The system retrieves values of various types from diverse sources. It may derive from them some sort of status indicating issues. For example, the total amount of free memory should be above a certain theshold, and the user with the id <code>0</code> should always be named “root”.</p>
<p>For management reasons, we probably want type erasure on the top level. However, we also need to provide specific (user configurable) assesments for specific types of data sources (e.g. thresholds and ranges for numerical types). And since sources for these values are diverse, we may choose to supply data sources as closures that return a value when called. Because we are probably getting those values from the operating system, we are likely confronted with operations that may fail.</p>
<p>We thus may have settled on the following types and traits for handling specific values:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Value&lt;G: FnMut() -&gt; Result&lt;T, Error&gt;, S: Fn(&amp;T) -&gt; Status, T: Display&gt; {
    value: Option&lt;T&gt;,
    getter: G,
    status: S,
}

impl&lt;G: FnMut() -&gt; Result&lt;T, Error&gt;, S: Fn(&amp;T) -&gt; Status, T: Display&gt; Value&lt;G, S, T&gt; {
    pub fn update(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
        (self.getter)().map(|v| self.value = Some(v))
    }

    pub fn value(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.value.as_ref()
    }

    pub fn status(&amp;self) -&gt; Option&lt;Status&gt; {
        self.value().map(&amp;self.status)
    }
}

// ...

enum Status {
    // ...
}

struct Error {
    // ...
}
<span class="boring">}</span></code></pre>
<p>With these types, we will need to repeat the trait bounds for <code>G</code> in at least a few places. Readability suffers, partially due the the fact that the getter returns a <code>Result</code>. Introducing a bound for “getters” allows a more expressive bound and eliminate one of the type parameters:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Display;
</span>trait Getter {
    type Output: Display;

    fn get_value(&amp;mut self) -&gt; Result&lt;Self::Output, Error&gt;;
}

impl&lt;F: FnMut() -&gt; Result&lt;T, Error&gt;, T: Display&gt; Getter for F {
    type Output = T;

    fn get_value(&amp;mut self) -&gt; Result&lt;Self::Output, Error&gt; {
        self()
    }
}

struct Value&lt;G: Getter, S: Fn(&amp;G::Output) -&gt; Status&gt; {
    value: Option&lt;G::Output&gt;,
    getter: G,
    status: S,
}

// ...
<span class="boring">enum Status {}
</span><span class="boring">struct Error;
</span><span class="boring">}</span></code></pre>
<h2 id="advantages-19"><a class="header" href="#advantages-19">Advantages</a></h2>
<p>Introducing a new trait can help simplify type bounds, particularly via the elimination of type parameters. A good name for the new trait will also make the bound more expressive. The new trait, an abstraction, also offers opportunities in itself, including:</p>
<ul>
<li>additional, specialized types implementing the new trait (e.g. representing an idendity of some sort) as well as other useful traits such as <code>Default</code> and</li>
<li>additional methods, as long as they can be implemented for all relevant types.</li>
</ul>
<h2 id="disadvantages-19"><a class="header" href="#disadvantages-19">Disadvantages</a></h2>
<p>Introducing new items such as the trait means we need to find an appropriate name and place for it. It also means one more item users of the original functionality need to investigate<sup class="footnote-reference" id="fr-read-docs-1"><a href="#footnote-read-docs">2</a></sup>. Depending on presentation, it may not be obvious right away that a simple closure may be used as a <code>Getter</code> in the example above.</p>
<footer id="last-change-36">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer>
<hr>
<ol class="footnote-definition">
<li id="footnote-fn-traits">
<p>i.e. <code>Fn</code>, <code>FnOnce</code> and <code>FnMut</code> <a href="#fr-fn-traits-1">↩</a></p>
</li>
<li id="footnote-read-docs">
<p>meaning they may need to read more documentation <a href="#fr-read-docs-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ffi-patterns"><a class="header" href="#ffi-patterns">FFI Patterns</a></h1>
<p>Writing FFI code is an entire course in itself. However, there are several idioms here that can act as pointers, and avoid traps for inexperienced users of unsafe Rust.</p>
<p>This section contains design patterns that may be useful when doing FFI.</p>
<ol>
<li>
<p><a href="#object-based-apis">Object-Based API</a> design that has good memory safety characteristics, and a clean boundary of what is safe and what is unsafe</p>
</li>
<li>
<p><a href="#type-consolidation-into-wrappers">Type Consolidation into Wrappers</a> - group multiple Rust types together into an opaque “object”</p>
</li>
</ol>
<footer id="last-change-37">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="object-based-apis"><a class="header" href="#object-based-apis">Object-Based APIs</a></h1>
<h2 id="description-29"><a class="header" href="#description-29">Description</a></h2>
<p>When designing APIs in Rust which are exposed to other languages, there are some important design principles which are contrary to normal Rust API design:</p>
<ol>
<li>All Encapsulated types should be <em>owned</em> by Rust, <em>managed</em> by the user, and <em>opaque</em>.</li>
<li>All Transactional data types should be <em>owned</em> by the user, and <em>transparent</em>.</li>
<li>All library behavior should be functions acting upon Encapsulated types.</li>
<li>All library behavior should be encapsulated into types not based on structure, but <em>provenance/lifetime</em>.</li>
</ol>
<h2 id="motivation-17"><a class="header" href="#motivation-17">Motivation</a></h2>
<p>Rust has built-in FFI support to other languages. It does this by providing a way for crate authors to provide C-compatible APIs through different ABIs (though that is unimportant to this practice).</p>
<p>Well-designed Rust FFI follows C API design principles, while compromising the design in Rust as little as possible. There are three goals with any foreign API:</p>
<ol>
<li>Make it easy to use in the target language.</li>
<li>Avoid the API dictating internal unsafety on the Rust side as much as possible.</li>
<li>Keep the potential for memory unsafety and Rust <code>undefined behaviour</code> as small as possible.</li>
</ol>
<p>Rust code must trust the memory safety of the foreign language beyond a certain point. However, every bit of <code>unsafe</code> code on the Rust side is an opportunity for bugs, or to exacerbate <code>undefined behaviour</code>.</p>
<p>For example, if a pointer provenance is wrong, that may be a segfault due to invalid memory access. But if it is manipulated by unsafe code, it could become full-blown heap corruption.</p>
<p>The Object-Based API design allows for writing shims that have good memory safety characteristics, and a clean boundary of what is safe and what is <code>unsafe</code>.</p>
<h2 id="code-example-3"><a class="header" href="#code-example-3">Code Example</a></h2>
<p>The POSIX standard defines the API to access an on-file database, known as <a href="https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h">DBM</a>. It is an excellent example of an “object-based” API.</p>
<p>Here is the definition in C, which hopefully should be easy to read for those involved in FFI. The commentary below should help explain it for those who miss the subtleties.</p>
<pre><code class="language-C">struct DBM;
typedef struct { void *dptr, size_t dsize } datum;

int     dbm_clearerr(DBM *);
void    dbm_close(DBM *);
int     dbm_delete(DBM *, datum);
int     dbm_error(DBM *);
datum   dbm_fetch(DBM *, datum);
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
DBM    *dbm_open(const char *, int, mode_t);
int     dbm_store(DBM *, datum, datum, int);
</code></pre>
<p>This API defines two types: <code>DBM</code> and <code>datum</code>.</p>
<p>The <code>DBM</code> type was called an “encapsulated” type above. It is designed to contain internal state, and acts as an entry point for the library’s behavior.</p>
<p>It is completely opaque to the user, who cannot create a <code>DBM</code> themselves since they don’t know its size or layout. Instead, they must call <code>dbm_open</code>, and that only gives them <em>a pointer to one</em>.</p>
<p>This means all <code>DBM</code>s are “owned” by the library in a Rust sense. The internal state of unknown size is kept in memory controlled by the library, not the user. The user can only manage its life cycle with <code>open</code> and <code>close</code>, and perform operations on it with the other functions.</p>
<p>The <code>datum</code> type was called a “transactional” type above. It is designed to facilitate the exchange of information between the library and its user.</p>
<p>The database is designed to store “unstructured data”, with no pre-defined length or meaning. As a result, the <code>datum</code> is the C equivalent of a Rust slice: a bunch of bytes, and a count of how many there are. The main difference is that there is no type information, which is what <code>void</code> indicates.</p>
<p>Keep in mind that this header is written from the library’s point of view. The user likely has some type they are using, which has a known size. But the library does not care, and by the rules of C casting, any type behind a pointer can be cast to <code>void</code>.</p>
<p>As noted earlier, this type is <em>transparent</em> to the user. But also, this type is <em>owned</em> by the user. This has subtle ramifications, due to that pointer inside it. The question is, who owns the memory that pointer points to?</p>
<p>The answer for best memory safety is, “the user”. But in cases such as retrieving a value, the user does not know how to allocate it correctly (since they don’t know how long the value is). In this case, the library code is expected to use the heap that the user has access to – such as the C library <code>malloc</code> and <code>free</code> – and then <em>transfer ownership</em> in the Rust sense.</p>
<p>This may all seem speculative, but this is what a pointer means in C. It means the same thing as Rust: “user defined lifetime.” The user of the library needs to read the documentation in order to use it correctly. That said, there are some decisions that have fewer or greater consequences if users do it wrong. Minimizing those are what this best practice is about, and the key is to <em>transfer ownership of everything that is transparent</em>.</p>
<h2 id="advantages-20"><a class="header" href="#advantages-20">Advantages</a></h2>
<p>This minimizes the number of memory safety guarantees the user must uphold to a relatively small number:</p>
<ol>
<li>Do not call any function with a pointer not returned by <code>dbm_open</code> (invalid access or corruption).</li>
<li>Do not call any function on a pointer after close (use after free).</li>
<li>The <code>dptr</code> on any <code>datum</code> must be <code>NULL</code>, or point to a valid slice of memory at the advertised length.</li>
</ol>
<p>In addition, it avoids a lot of pointer provenance issues. To understand why, let us consider an alternative in some depth: key iteration.</p>
<p>Rust is well known for its iterators. When implementing one, the programmer makes a separate type with a bounded lifetime to its owner, and implements the <code>Iterator</code> trait.</p>
<p>Here is how iteration would be done in Rust for <code>DBM</code>:</p>
<pre><code class="language-rust ignore">struct Dbm { ... }

impl Dbm {
    /* ... */
    pub fn keys&lt;'it&gt;(&amp;'it self) -&gt; DbmKeysIter&lt;'it&gt; { ... }
    /* ... */
}

struct DbmKeysIter&lt;'it&gt; {
    owner: &amp;'it Dbm,
}

impl&lt;'it&gt; Iterator for DbmKeysIter&lt;'it&gt; { ... }</code></pre>
<p>This is clean, idiomatic, and safe. thanks to Rust’s guarantees. However, consider what a straightforward API translation would look like:</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern "C" fn dbm_iter_new(owner: *const Dbm) -&gt; *mut DbmKeysIter {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern "C" fn dbm_iter_next(
    iter: *mut DbmKeysIter,
    key_out: *const datum
) -&gt; libc::c_int {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}
#[no_mangle]
pub extern "C" fn dbm_iter_del(*mut DbmKeysIter) {
    // THIS API IS A BAD IDEA! For real applications, use object-based design instead.
}</code></pre>
<p>This API loses a key piece of information: the lifetime of the iterator must not exceed the lifetime of the <code>Dbm</code> object that owns it. A user of the library could use it in a way which causes the iterator to outlive the data it is iterating on, resulting in reading uninitialized memory.</p>
<p>This example written in C contains a bug that will be explained afterwards:</p>
<pre><code class="language-C">int count_key_sizes(DBM *db) {
    // DO NOT USE THIS FUNCTION. IT HAS A SUBTLE BUT SERIOUS BUG!
    datum key;
    int len = 0;

    if (!dbm_iter_new(db)) {
        dbm_close(db);
        return -1;
    }

    int l;
    while ((l = dbm_iter_next(owner, &amp;key)) &gt;= 0) { // an error is indicated by -1
        free(key.dptr);
        len += key.dsize;
        if (l == 0) { // end of the iterator
            dbm_close(owner);
        }
    }
    if l &gt;= 0 {
        return -1;
    } else {
        return len;
    }
}
</code></pre>
<p>This bug is a classic. Here’s what happens when the iterator returns the end-of-iteration marker:</p>
<ol>
<li>The loop condition sets <code>l</code> to zero, and enters the loop because <code>0 &gt;= 0</code>.</li>
<li>The length is incremented, in this case by zero.</li>
<li>The if statement is true, so the database is closed. There should be a break statement here.</li>
<li>The loop condition executes again, causing a <code>next</code> call on the closed object.</li>
</ol>
<p>The worst part about this bug? If the Rust implementation was careful, this code will work most of the time! If the memory for the <code>Dbm</code> object is not immediately reused, an internal check will almost certainly fail, resulting in the iterator returning a <code>-1</code> indicating an error. But occasionally, it will cause a segmentation fault, or even worse, nonsensical memory corruption!</p>
<p>None of this can be avoided by Rust. From its perspective, it put those objects on its heap, returned pointers to them, and gave up control of their lifetimes. The C code simply must “play nice”.</p>
<p>The programmer must read and understand the API documentation. While some consider that par for the course in C, a good API design can mitigate this risk. The POSIX API for <code>DBM</code> did this by <em>consolidating the ownership</em> of the iterator with its parent:</p>
<pre><code class="language-C">datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
</code></pre>
<p>Thus, all the lifetimes were bound together, and such unsafety was prevented.</p>
<h2 id="disadvantages-20"><a class="header" href="#disadvantages-20">Disadvantages</a></h2>
<p>However, this design choice also has a number of drawbacks, which should be considered as well.</p>
<p>First, the API itself becomes less expressive. With POSIX DBM, there is only one iterator per object, and every call changes its state. This is much more restrictive than iterators in almost any language, even though it is safe. Perhaps with other related objects, whose lifetimes are less hierarchical, this limitation is more of a cost than the safety.</p>
<p>Second, depending on the relationships of the API’s parts, significant design effort may be involved. Many of the easier design points have other patterns associated with them:</p>
<ul>
<li>
<p><a href="#type-consolidation-into-wrappers">Wrapper Type Consolidation</a> groups multiple Rust types together into an opaque “object”</p>
</li>
<li>
<p><a href="#error-handling-in-ffi">FFI Error Passing</a> explains error handling with integer codes and sentinel return values (such as <code>NULL</code> pointers)</p>
</li>
<li>
<p><a href="#accepting-strings">Accepting Foreign Strings</a> allows accepting strings with minimal unsafe code, and is easier to get right than <a href="#passing-strings">Passing Strings to FFI</a></p>
</li>
</ul>
<p>However, not every API can be done this way. It is up to the best judgement of the programmer as to who their audience is.</p>
<footer id="last-change-38">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-consolidation-into-wrappers"><a class="header" href="#type-consolidation-into-wrappers">Type Consolidation into Wrappers</a></h1>
<h2 id="description-30"><a class="header" href="#description-30">Description</a></h2>
<p>This pattern is designed to allow gracefully handling multiple related types, while minimizing the surface area for memory unsafety.</p>
<p>One of the cornerstones of Rust’s aliasing rules is lifetimes. This ensures that many patterns of access between types can be memory safe, data race safety included.</p>
<p>However, when Rust types are exported to other languages, they are usually transformed into pointers. In Rust, a pointer means “the user manages the lifetime of the pointee.” It is their responsibility to avoid memory unsafety.</p>
<p>Some level of trust in the user code is thus required, notably around use-after-free which Rust can do nothing about. However, some API designs place higher burdens than others on the code written in the other language.</p>
<p>The lowest risk API is the “consolidated wrapper”, where all possible interactions with an object are folded into a “wrapper type”, while keeping the Rust API clean.</p>
<h2 id="code-example-4"><a class="header" href="#code-example-4">Code Example</a></h2>
<p>To understand this, let us look at a classic example of an API to export: iteration through a collection.</p>
<p>That API looks like this:</p>
<ol>
<li>The iterator is initialized with <code>first_key</code>.</li>
<li>Each call to <code>next_key</code> will advance the iterator.</li>
<li>Calls to <code>next_key</code> if the iterator is at the end will do nothing.</li>
<li>As noted above, the iterator is “wrapped into” the collection (unlike the native Rust API).</li>
</ol>
<p>If the iterator implements <code>nth()</code> efficiently, then it is possible to make it ephemeral to each function call:</p>
<pre><code class="language-rust ignore">struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
}

impl MySetWrapper {
    pub fn first_key(&amp;mut self) -&gt; Option&lt;&amp;Key&gt; {
        self.iter_next = 0;
        self.next_key()
    }
    pub fn next_key(&amp;mut self) -&gt; Option&lt;&amp;Key&gt; {
        if let Some(next) = self.myset.keys().nth(self.iter_next) {
            self.iter_next += 1;
            Some(next)
        } else {
            None
        }
    }
}</code></pre>
<p>As a result, the wrapper is simple and contains no <code>unsafe</code> code.</p>
<h2 id="advantages-21"><a class="header" href="#advantages-21">Advantages</a></h2>
<p>This makes APIs safer to use, avoiding issues with lifetimes between types. See <a href="#object-based-apis">Object-Based APIs</a> for more on the advantages and pitfalls this avoids.</p>
<h2 id="disadvantages-21"><a class="header" href="#disadvantages-21">Disadvantages</a></h2>
<p>Often, wrapping types is quite difficult, and sometimes a Rust API compromise would make things easier.</p>
<p>As an example, consider an iterator which does not efficiently implement <code>nth()</code>. It would definitely be worth putting in special logic to make the object handle iteration internally, or to support a different access pattern efficiently that only the Foreign Function API will use.</p>
<h3 id="trying-to-wrap-iterators-and-failing"><a class="header" href="#trying-to-wrap-iterators-and-failing">Trying to Wrap Iterators (and Failing)</a></h3>
<p>To wrap any type of iterator into the API correctly, the wrapper would need to do what a C version of the code would do: erase the lifetime of the iterator, and manage it manually.</p>
<p>Suffice it to say, this is <em>incredibly</em> difficult.</p>
<p>Here is an illustration of just <em>one</em> pitfall.</p>
<p>A first version of <code>MySetWrapper</code> would look like this:</p>
<pre><code class="language-rust ignore">struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
    // created from a transmuted Box&lt;KeysIter + 'self&gt;
    iterator: Option&lt;NonNull&lt;KeysIter&lt;'static&gt;&gt;&gt;,
}</code></pre>
<p>With <code>transmute</code> being used to extend a lifetime, and a pointer to hide it, it’s ugly already. But it gets even worse: <em>any other operation can cause Rust <code>undefined behaviour</code></em>.</p>
<p>Consider that the <code>MySet</code> in the wrapper could be manipulated by other functions during iteration, such as storing a new value to the key it was iterating over. The API doesn’t discourage this, and in fact some similar C libraries expect it.</p>
<p>A simple implementation of <code>myset_store</code> would be:</p>
<pre><code class="language-rust ignore">pub mod unsafe_module {

    // other module content

    pub fn myset_store(myset: *mut MySetWrapper, key: datum, value: datum) -&gt; libc::c_int {
        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROBLEM.

        let myset: &amp;mut MySet = unsafe {
            // SAFETY: whoops, UB occurs in here!
            &amp;mut (*myset).myset
        };

        /* ...check and cast key and value data... */

        match myset.store(casted_key, casted_value) {
            Ok(_) =&gt; 0,
            Err(e) =&gt; e.into(),
        }
    }
}</code></pre>
<p>If the iterator exists when this function is called, we have violated one of Rust’s aliasing rules. According to Rust, the mutable reference in this block must have <em>exclusive</em> access to the object. If the iterator simply exists, it’s not exclusive, so we have <code>undefined behaviour</code>! <sup class="footnote-reference" id="fr-1-1-1"><a href="#footnote-1-1">1</a></sup></p>
<p>To avoid this, we must have a way of ensuring that mutable reference really is exclusive. That basically means clearing out the iterator’s shared reference while it exists, and then reconstructing it. In most cases, that will still be less efficient than the C version.</p>
<p>Some may ask: how can C do this more efficiently? The answer is, it cheats. Rust’s aliasing rules are the problem, and C simply ignores them for its pointers. In exchange, it is common to see code that is declared in the manual as “not thread safe” under some or all circumstances. In fact, the <a href="https://manpages.debian.org/buster/manpages/attributes.7.en.html">GNU C library</a> has an entire lexicon dedicated to concurrent behavior!</p>
<p>Rust would rather make everything memory safe all the time, for both safety and optimizations that C code cannot attain. Being denied access to certain shortcuts is the price Rust programmers need to pay.</p>
<footer id="last-change-39">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer>
<hr>
<ol class="footnote-definition">
<li id="footnote-1-1">
<p>For the C programmers out there scratching their heads, the iterator need not be read <em>during</em> this code to cause the UB. The exclusivity rule also enables compiler optimizations which may cause inconsistent observations by the iterator’s shared reference (e.g. stack spills or reordering instructions for efficiency). These observations may happen <em>any time after</em> the mutable reference is created. <a href="#fr-1-1-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-patterns</a></h1>
<p>An <a href="https://en.wikipedia.org/wiki/Anti-pattern">anti-pattern</a> is a solution to a “recurring problem that is usually ineffective and risks being highly counterproductive”. Just as valuable as knowing how to solve a problem, is knowing how <em>not</em> to solve it. Anti-patterns give us great counter-examples to consider relative to design patterns. Anti-patterns are not confined to code. For example, a process can be an anti-pattern, too.</p>
<footer id="last-change-40">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="clone-to-satisfy-the-borrow-checker"><a class="header" href="#clone-to-satisfy-the-borrow-checker">Clone to satisfy the borrow checker</a></h1>
<h2 id="description-31"><a class="header" href="#description-31">Description</a></h2>
<p>The borrow checker prevents Rust users from developing otherwise unsafe code by ensuring that either: only one mutable reference exists, or potentially many but all immutable references exist. If the code written does not hold true to these conditions, this anti-pattern arises when the developer resolves the compiler error by cloning the variable.</p>
<h2 id="example-21"><a class="header" href="#example-21">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// define any variable
let mut x = 5;

// Borrow `x` -- but clone it first
let y = &amp;mut (x.clone());

// without the x.clone() two lines prior, this line would fail on compile as
// x has been borrowed
// thanks to x.clone(), x was never borrowed, and this line will run.
println!("{x}");

// perform some action on the borrow to prevent rust from optimizing this
//out of existence
*y += 1;
<span class="boring">}</span></code></pre>
<h2 id="motivation-18"><a class="header" href="#motivation-18">Motivation</a></h2>
<p>It is tempting, particularly for beginners, to use this pattern to resolve confusing issues with the borrow checker. However, there are serious consequences. Using <code>.clone()</code> causes a copy of the data to be made. Any changes between the two are not synchronized – as if two completely separate variables exist.</p>
<p>There are special cases – <code>Rc&lt;T&gt;</code> is designed to handle clones intelligently. It internally manages exactly one copy of the data. Invoking <code>.clone()</code> on <code>Rc</code> produces a new <code>Rc</code> instance, which points to the same data as the source <code>Rc</code>, while increasing a reference count. The same applies to <code>Arc</code>, the thread-safe counterpart of <code>Rc</code>.</p>
<p>In general, clones should be deliberate, with full understanding of the consequences. If a clone is used to make a borrow checker error disappear, that’s a good indication this anti-pattern may be in use.</p>
<p>Even though <code>.clone()</code> is an indication of a bad pattern, sometimes <strong>it is fine to write inefficient code</strong>, in cases such as when:</p>
<ul>
<li>the developer is still new to ownership</li>
<li>the code doesn’t have great speed or memory constraints (like hackathon projects or prototypes)</li>
<li>satisfying the borrow checker is really complicated, and you prefer to optimize readability over performance</li>
</ul>
<p>If an unnecessary clone is suspected, The <a href="https://doc.rust-lang.org/book/ownership.html">Rust Book’s chapter on Ownership</a> should be understood fully before assessing whether the clone is required or not.</p>
<p>Also be sure to always run <code>cargo clippy</code> in your project, which will detect some cases in which <code>.clone()</code> is not necessary.</p>
<h2 id="see-also-19"><a class="header" href="#see-also-19">See also</a></h2>
<ul>
<li><a href="#memtake_-replace_-to-keep-owned-values-in-changed-enums"><code>mem::{take(_), replace(_)}</code> to keep owned values in changed enums</a></li>
<li><a href="http://doc.rust-lang.org/std/rc/"><code>Rc&lt;T&gt;</code> documentation, which handles .clone() intelligently</a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code> documentation, a thread-safe reference-counting pointer</a></li>
<li><a href="https://web.archive.org/web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html">Tricks with ownership in Rust</a></li>
</ul>
<footer id="last-change-41">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="denywarnings"><a class="header" href="#denywarnings"><code>#![deny(warnings)]</code></a></h1>
<h2 id="description-32"><a class="header" href="#description-32">Description</a></h2>
<p>A well-intentioned crate author wants to ensure their code builds without warnings. So they annotate their crate root with the following:</p>
<h2 id="example-22"><a class="header" href="#example-22">Example</a></h2>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>#![deny(warnings)]

<span class="boring">fn main() {
</span>// All is well.
<span class="boring">}</span></code></pre>
<h2 id="advantages-22"><a class="header" href="#advantages-22">Advantages</a></h2>
<p>It is short and will stop the build if anything is amiss.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>By disallowing the compiler to build with warnings, a crate author opts out of Rust’s famed stability. Sometimes new features or old misfeatures need a change in how things are done, thus lints are written that <code>warn</code> for a certain grace period before being turned to <code>deny</code>.</p>
<p>For example, it was discovered that a type could have two <code>impl</code>s with the same method. This was deemed a bad idea, but in order to make the transition smooth, the <code>overlapping-inherent-impls</code> lint was introduced to give a warning to those stumbling on this fact, before it becomes a hard error in a future release.</p>
<p>Also sometimes APIs get deprecated, so their use will emit a warning where before there was none.</p>
<p>All this conspires to potentially break the build whenever something changes.</p>
<p>Furthermore, crates that supply additional lints (e.g. <a href="https://github.com/rust-lang/rust-clippy">rust-clippy</a>) can no longer be used unless the annotation is removed. This is mitigated with <a href="https://doc.rust-lang.org/rustc/lints/levels.html#capping-lints">--cap-lints</a>. The <code>--cap-lints=warn</code> command line argument, turns all <code>deny</code> lint errors into warnings.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>There are two ways of tackling this problem: First, we can decouple the build setting from the code, and second, we can name the lints we want to deny explicitly.</p>
<p>The following command line will build with all warnings set to <code>deny</code>:</p>
<p><code>RUSTFLAGS="-D warnings" cargo build</code></p>
<p>This can be done by any individual developer (or be set in a CI tool like Travis, but remember that this may break the build when something changes) without requiring a change to the code.</p>
<p>Alternatively, we can specify the lints that we want to <code>deny</code> in the code. Here is a list of warning lints that is (hopefully) safe to deny (as of rustc 1.48.0):</p>
<pre><code class="language-rust ignore">#![deny(
    bad_style,
    const_err,
    dead_code,
    improper_ctypes,
    non_shorthand_field_patterns,
    no_mangle_generic_items,
    overflowing_literals,
    path_statements,
    patterns_in_fns_without_body,
    private_in_public,
    unconditional_recursion,
    unused,
    unused_allocation,
    unused_comparisons,
    unused_parens,
    while_true
)]</code></pre>
<p>In addition, the following <code>allow</code>ed lints may be a good idea to <code>deny</code>:</p>
<pre><code class="language-rust ignore">#![deny(
    missing_debug_implementations,
    missing_docs,
    trivial_casts,
    trivial_numeric_casts,
    unused_extern_crates,
    unused_import_braces,
    unused_qualifications,
    unused_results
)]</code></pre>
<p>Some may also want to add <code>missing-copy-implementations</code> to their list.</p>
<p>Note that we explicitly did not add the <code>deprecated</code> lint, as it is fairly certain that there will be more deprecated APIs in the future.</p>
<h2 id="see-also-20"><a class="header" href="#see-also-20">See also</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master">A collection of all clippy lints</a></li>
<li><a href="https://doc.rust-lang.org/reference/attributes.html#deprecation">deprecate attribute</a> documentation</li>
<li>Type <code>rustc -W help</code> for a list of lints on your system. Also type <code>rustc --help</code> for a general list of options</li>
<li><a href="https://github.com/rust-lang/rust-clippy">rust-clippy</a> is a collection of lints for better Rust code</li>
</ul>
<footer id="last-change-42">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="deref-polymorphism"><a class="header" href="#deref-polymorphism"><code>Deref</code> polymorphism</a></h1>
<h2 id="description-33"><a class="header" href="#description-33">Description</a></h2>
<p>Misuse the <code>Deref</code> trait to emulate inheritance between structs, and thus reuse methods.</p>
<h2 id="example-23"><a class="header" href="#example-23">Example</a></h2>
<p>Sometimes we want to emulate the following common pattern from OO languages such as Java:</p>
<pre><code class="language-java">class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}
</code></pre>
<p>We can use the deref polymorphism anti-pattern to do so:</p>
<pre class="playground"><code class="language-rust edition2024">use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&amp;self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}</code></pre>
<p>There is no struct inheritance in Rust. Instead we use composition and include an instance of <code>Foo</code> in <code>Bar</code> (since the field is a value, it is stored inline, so if there were fields, they would have the same layout in memory as the Java version (probably, you should use <code>#[repr(C)]</code> if you want to be sure)).</p>
<p>In order to make the method call work we implement <code>Deref</code> for <code>Bar</code> with <code>Foo</code> as the target (returning the embedded <code>Foo</code> field). That means that when we dereference a <code>Bar</code> (for example, using <code>*</code>) then we will get a <code>Foo</code>. That is pretty weird. Dereferencing usually gives a <code>T</code> from a reference to <code>T</code>, here we have two unrelated types. However, since the dot operator does implicit dereferencing, it means that the method call will search for methods on <code>Foo</code> as well as <code>Bar</code>.</p>
<h2 id="advantages-23"><a class="header" href="#advantages-23">Advantages</a></h2>
<p>You save a little boilerplate, e.g.,</p>
<pre><code class="language-rust ignore">impl Bar {
    fn m(&amp;self) {
        self.f.m()
    }
}</code></pre>
<h2 id="disadvantages-22"><a class="header" href="#disadvantages-22">Disadvantages</a></h2>
<p>Most importantly this is a surprising idiom - future programmers reading this in code will not expect this to happen. That’s because we are misusing the <code>Deref</code> trait rather than using it as intended (and documented, etc.). It’s also because the mechanism here is completely implicit.</p>
<p>This pattern does not introduce subtyping between <code>Foo</code> and <code>Bar</code> like inheritance in Java or C++ does. Furthermore, traits implemented by <code>Foo</code> are not automatically implemented for <code>Bar</code>, so this pattern interacts badly with bounds checking and thus generic programming.</p>
<p>Using this pattern gives subtly different semantics from most OO languages with regards to <code>self</code>. Usually it remains a reference to the sub-class, with this pattern it will be the ‘class’ where the method is defined.</p>
<p>Finally, this pattern only supports single inheritance, and has no notion of interfaces, class-based privacy, or other inheritance-related features. So, it gives an experience that will be subtly surprising to programmers used to Java inheritance, etc.</p>
<h2 id="discussion-15"><a class="header" href="#discussion-15">Discussion</a></h2>
<p>There is no one good alternative. Depending on the exact circumstances it might be better to re-implement using traits or to write out the facade methods to dispatch to <code>Foo</code> manually. We do intend to add a mechanism for inheritance similar to this to Rust, but it is likely to be some time before it reaches stable Rust. See these <a href="http://aturon.github.io/blog/2015/09/18/reuse/">blog</a> <a href="http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/">posts</a> and this <a href="https://github.com/rust-lang/rfcs/issues/349">RFC issue</a> for more details.</p>
<p>The <code>Deref</code> trait is designed for the implementation of custom pointer types. The intention is that it will take a pointer-to-<code>T</code> to a <code>T</code>, not convert between different types. It is a shame that this isn’t (probably cannot be) enforced by the trait definition.</p>
<p>Rust tries to strike a careful balance between explicit and implicit mechanisms, favouring explicit conversions between types. Automatic dereferencing in the dot operator is a case where the ergonomics strongly favour an implicit mechanism, but the intention is that this is limited to degrees of indirection, not conversion between arbitrary types.</p>
<h2 id="see-also-21"><a class="header" href="#see-also-21">See also</a></h2>
<ul>
<li><a href="#collections-are-smart-pointers">Collections are smart pointers idiom</a>.</li>
<li>Delegation crates for less boilerplate like <a href="https://crates.io/crates/delegate">delegate</a> or <a href="https://crates.io/crates/ambassador">ambassador</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Documentation for <code>Deref</code> trait</a>.</li>
</ul>
<footer id="last-change-43">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="functional-usage-of-rust"><a class="header" href="#functional-usage-of-rust">Functional Usage of Rust</a></h1>
<p>Rust is an imperative language, but it follows many <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> paradigms.</p>
<blockquote>
<p>In computer science, <em>functional programming</em> is a programming paradigm where programs are constructed by applying and composing functions. It is a declarative programming paradigm in which function definitions are trees of expressions that each return a value, rather than a sequence of imperative statements which change the state of the program.</p>
</blockquote>
<footer id="last-change-44">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="programming-paradigms"><a class="header" href="#programming-paradigms">Programming paradigms</a></h1>
<p>One of the biggest hurdles to understanding functional programs when coming from an imperative background is the shift in thinking. Imperative programs describe <strong>how</strong> to do something, whereas declarative programs describe <strong>what</strong> to do. Let’s sum the numbers from 1 to 10 to show this.</p>
<h2 id="imperative"><a class="header" href="#imperative">Imperative</a></h2>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{sum}");
<span class="boring">}</span></code></pre>
<p>With imperative programs, we have to play compiler to see what is happening. Here, we start with a <code>sum</code> of <code>0</code>. Next, we iterate through the range from 1 to 10. Each time through the loop, we add the corresponding value in the range. Then we print it out.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: center"><code>i</code></th><th style="text-align: center"><code>sum</code></th></tr>
</thead>
<tbody>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">6</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">10</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">15</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">21</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">28</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">36</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: center">45</td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: center">55</td></tr>
</tbody>
</table>
</div>
<p>This is how most of us start out programming. We learn that a program is a set of steps.</p>
<h2 id="declarative"><a class="header" href="#declarative">Declarative</a></h2>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("{}", (1..11).fold(0, |a, b| a + b));
<span class="boring">}</span></code></pre>
<p>Whoa! This is really different! What’s going on here? Remember that with declarative programs we are describing <strong>what</strong> to do, rather than <strong>how</strong> to do it. <code>fold</code> is a function that <a href="https://en.wikipedia.org/wiki/Function_composition">composes</a> functions. The name is a convention from Haskell.</p>
<p>Here, we are composing functions of addition (this closure: <code>|a, b| a + b</code>) with a range from 1 to 10. The <code>0</code> is the starting point, so <code>a</code> is <code>0</code> at first. <code>b</code> is the first element of the range, <code>1</code>. <code>0 + 1 = 1</code> is the result. So now we <code>fold</code> again, with <code>a = 1</code>, <code>b = 2</code> and so <code>1 + 2 = 3</code> is the next result. This process continues until we get to the last element in the range, <code>10</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: center"><code>a</code></th><th style="text-align: center"><code>b</code></th><th style="text-align: center">result</th></tr>
</thead>
<tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">6</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">4</td><td style="text-align: center">10</td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: center">5</td><td style="text-align: center">15</td></tr>
<tr><td style="text-align: center">15</td><td style="text-align: center">6</td><td style="text-align: center">21</td></tr>
<tr><td style="text-align: center">21</td><td style="text-align: center">7</td><td style="text-align: center">28</td></tr>
<tr><td style="text-align: center">28</td><td style="text-align: center">8</td><td style="text-align: center">36</td></tr>
<tr><td style="text-align: center">36</td><td style="text-align: center">9</td><td style="text-align: center">45</td></tr>
<tr><td style="text-align: center">45</td><td style="text-align: center">10</td><td style="text-align: center">55</td></tr>
</tbody>
</table>
</div>
<footer id="last-change-45">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="generics-as-type-classes"><a class="header" href="#generics-as-type-classes">Generics as Type Classes</a></h1>
<h2 id="description-34"><a class="header" href="#description-34">Description</a></h2>
<p>Rust’s type system is designed more like functional languages (like Haskell) rather than imperative languages (like Java and C++). As a result, Rust can turn many kinds of programming problems into “static typing” problems. This is one of the biggest wins of choosing a functional language, and is critical to many of Rust’s compile time guarantees.</p>
<p>A key part of this idea is the way generic types work. In C++ and Java, for example, generic types are a meta-programming construct for the compiler. <code>vector&lt;int&gt;</code> and <code>vector&lt;char&gt;</code> in C++ are just two different copies of the same boilerplate code for a <code>vector</code> type (known as a <code>template</code>) with two different types filled in.</p>
<p>In Rust, a generic type parameter creates what is known in functional languages as a “type class constraint”, and each different parameter filled in by an end user <em>actually changes the type</em>. In other words, <code>Vec&lt;isize&gt;</code> and <code>Vec&lt;char&gt;</code> <em>are two different types</em>, which are recognized as distinct by all parts of the type system.</p>
<p>This is called <strong>monomorphization</strong>, where different types are created from <strong>polymorphic</strong> code. This special behavior requires <code>impl</code> blocks to specify generic parameters. Different values for the generic type cause different types, and different types can have different <code>impl</code> blocks.</p>
<p>In object-oriented languages, classes can inherit behavior from their parents. However, this allows the attachment of not only additional behavior to particular members of a type class, but extra behavior as well.</p>
<p>The nearest equivalent is the runtime polymorphism in Javascript and Python, where new members can be added to objects willy-nilly by any constructor. However, unlike those languages, all of Rust’s additional methods can be type checked when they are used, because their generics are statically defined. That makes them more usable while remaining safe.</p>
<h2 id="example-24"><a class="header" href="#example-24">Example</a></h2>
<p>Suppose you are designing a storage server for a series of lab machines. Because of the software involved, there are two different protocols you need to support: BOOTP (for PXE network boot), and NFS (for remote mount storage).</p>
<p>Your goal is to have one program, written in Rust, which can handle both of them. It will have protocol handlers and listen for both kinds of requests. The main application logic will then allow a lab administrator to configure storage and security controls for the actual files.</p>
<p>The requests from machines in the lab for files contain the same basic information, no matter what protocol they came from: an authentication method, and a file name to retrieve. A straightforward implementation would look something like this:</p>
<pre><code class="language-rust ignore">enum AuthInfo {
    Nfs(crate::nfs::AuthInfo),
    Bootp(crate::bootp::AuthInfo),
}

struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
}</code></pre>
<p>This design might work well enough. But now suppose you needed to support adding metadata that was <em>protocol specific</em>. For example, with NFS, you wanted to determine what their mount point was in order to enforce additional security rules.</p>
<p>The way the current struct is designed leaves the protocol decision until runtime. That means any method that applies to one protocol and not the other requires the programmer to do a runtime check.</p>
<p>Here is how getting an NFS mount point would look:</p>
<pre><code class="language-rust ignore">struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
    mount_point: Option&lt;PathBuf&gt;,
}

impl FileDownloadRequest {
    // ... other methods ...

    /// Gets an NFS mount point if this is an NFS request. Otherwise,
    /// return None.
    pub fn mount_point(&amp;self) -&gt; Option&lt;&amp;Path&gt; {
        self.mount_point.as_ref()
    }
}</code></pre>
<p>Every caller of <code>mount_point()</code> must check for <code>None</code> and write code to handle it. This is true even if they know only NFS requests are ever used in a given code path!</p>
<p>It would be far more optimal to cause a compile-time error if the different request types were confused. After all, the entire path of the user’s code, including what functions from the library they use, will know whether a request is an NFS request or a BOOTP request.</p>
<p>In Rust, this is actually possible! The solution is to <em>add a generic type</em> in order to split the API.</p>
<p>Here is what that looks like:</p>
<pre class="playground"><code class="language-rust edition2024">use std::path::{Path, PathBuf};

mod nfs {
    #[derive(Clone)]
    pub(crate) struct AuthInfo(String); // NFS session management omitted
}

mod bootp {
    pub(crate) struct AuthInfo(); // no authentication in bootp
}

// Keep the module private to prevent outside users from inventing their own protocols.
mod proto_trait {
    use super::{bootp, nfs};
    use std::path::{Path, PathBuf};

    pub(crate) trait ProtoKind {
        type AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo;
    }

    pub struct Nfs {
        auth: nfs::AuthInfo,
        mount_point: PathBuf,
    }

    impl Nfs {
        pub(crate) fn mount_point(&amp;self) -&gt; &amp;Path {
            &amp;self.mount_point
        }
    }

    impl ProtoKind for Nfs {
        type AuthInfo = nfs::AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo {
            self.auth.clone()
        }
    }

    pub struct Bootp(); // no additional metadata

    impl ProtoKind for Bootp {
        type AuthInfo = bootp::AuthInfo;
        fn auth_info(&amp;self) -&gt; Self::AuthInfo {
            bootp::AuthInfo()
        }
    }
}

use proto_trait::ProtoKind; // keep internal to prevent impls
pub use proto_trait::{Bootp, Nfs}; // re-export so callers can see them

struct FileDownloadRequest&lt;P: ProtoKind&gt; {
    file_name: PathBuf,
    protocol: P,
}

// all common API parts go into a generic impl block
impl&lt;P: ProtoKind&gt; FileDownloadRequest&lt;P&gt; {
    fn file_path(&amp;self) -&gt; &amp;Path {
        &amp;self.file_name
    }

    fn auth_info(&amp;self) -&gt; P::AuthInfo {
        self.protocol.auth_info()
    }
}

// all protocol-specific impls go into their own block
impl FileDownloadRequest&lt;Nfs&gt; {
    fn mount_point(&amp;self) -&gt; &amp;Path {
        self.protocol.mount_point()
    }
}

fn main() {
    // your code here
}</code></pre>
<p>With this approach, if the user were to make a mistake and use the wrong type;</p>
<pre><code class="language-rust ignore">fn main() {
    let mut socket = crate::bootp::listen()?;
    while let Some(request) = socket.next_request()? {
        match request.mount_point().as_ref() {
            "/secure" =&gt; socket.send("Access denied"),
            _ =&gt; {} // continue on...
        }
        // Rest of the code here
    }
}</code></pre>
<p>They would get a syntax error. The type <code>FileDownloadRequest&lt;Bootp&gt;</code> does not implement <code>mount_point()</code>, only the type <code>FileDownloadRequest&lt;Nfs&gt;</code> does. And that is created by the NFS module, not the BOOTP module of course!</p>
<h2 id="advantages-24"><a class="header" href="#advantages-24">Advantages</a></h2>
<p>First, it allows fields that are common to multiple states to be de-duplicated. By making the non-shared fields generic, they are implemented once.</p>
<p>Second, it makes the <code>impl</code> blocks easier to read, because they are broken down by state. Methods common to all states are typed once in one block, and methods unique to one state are in a separate block.</p>
<p>Both of these mean there are fewer lines of code, and they are better organized.</p>
<h2 id="disadvantages-23"><a class="header" href="#disadvantages-23">Disadvantages</a></h2>
<p>This currently increases the size of the binary, due to the way monomorphization is implemented in the compiler. Hopefully the implementation will be able to improve in the future.</p>
<h2 id="alternatives-1"><a class="header" href="#alternatives-1">Alternatives</a></h2>
<ul>
<li>
<p>If a type seems to need a “split API” due to construction or partial initialization, consider the <a href="#builder">Builder Pattern</a> instead.</p>
</li>
<li>
<p>If the API between types does not change – only the behavior does – then the <a href="#strategy-aka-policy">Strategy Pattern</a> is better used instead.</p>
</li>
</ul>
<h2 id="see-also-22"><a class="header" href="#see-also-22">See also</a></h2>
<p>This pattern is used throughout the standard library:</p>
<ul>
<li><code>Vec&lt;u8&gt;</code> can be cast from a String, unlike every other type of <code>Vec&lt;T&gt;</code>.<sup class="footnote-reference" id="fr-1-1-2"><a href="#footnote-1-2">1</a></sup></li>
<li>Iterators can be cast into a binary heap, but only if they contain a type that implements the <code>Ord</code> trait.<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup></li>
<li>The <code>to_string</code> method was specialized for <code>Cow</code> only of type <code>str</code>.<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup></li>
</ul>
<p>It is also used by several popular crates to allow API flexibility:</p>
<ul>
<li>
<p>The <code>embedded-hal</code> ecosystem used for embedded devices makes extensive use of this pattern. For example, it allows statically verifying the configuration of device registers used to control embedded pins. When a pin is put into a mode, it returns a <code>Pin&lt;MODE&gt;</code> struct, whose generic determines the functions usable in that mode, which are not on the <code>Pin</code> itself. <sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup></p>
</li>
<li>
<p>The <code>hyper</code> HTTP client library uses this to expose rich APIs for different pluggable requests. Clients with different connectors have different methods on them as well as different trait implementations, while a core set of methods apply to any connector. <sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">5</a></sup></p>
</li>
<li>
<p>The “type state” pattern – where an object gains and loses API based on an internal state or invariant – is implemented in Rust using the same basic concept, and a slightly different technique. <sup class="footnote-reference" id="fr-6-1"><a href="#footnote-6">6</a></sup></p>
</li>
</ul>
<footer id="last-change-46">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer>
<hr>
<ol class="footnote-definition">
<li id="footnote-1-2">
<p>See: <a href="https://doc.rust-lang.org/1.59.0/src/std/ffi/c_str.rs.html#803-811">impl From&lt;CString&gt; for Vec&lt;u8&gt;</a> <a href="#fr-1-1-2">↩</a></p>
</li>
<li id="footnote-2">
<p>See: <a href="https://web.archive.org/web/20201030132806/https://doc.rust-lang.org/stable/src/alloc/collections/binary_heap.rs.html#1330-1335">impl&lt;T: Ord&gt; FromIterator&lt;T&gt; for BinaryHeap&lt;T&gt;</a> <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>See: <a href="https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2235-2240">impl&lt;‘_&gt; ToString for Cow&lt;’_, str&gt;</a> <a href="#fr-3-1">↩</a></p>
</li>
<li id="footnote-4">
<p>Example: <a href="https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html">https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/struct.PA0.html</a> <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-5">
<p>See: <a href="https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html">https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html</a> <a href="#fr-5-1">↩</a></p>
</li>
<li id="footnote-6">
<p>See: <a href="https://web.archive.org/web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-typestate-pattern-the-typestate-pattern-itself/">The Case for the Type State Pattern</a> and <a href="https://web.archive.org/web/20210328164854/https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index">Rusty Typestate Series (an extensive thesis)</a> <a href="#fr-6-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="functional-language-optics"><a class="header" href="#functional-language-optics">Functional Language Optics</a></h1>
<p>Optics is a type of API design that is common to functional languages. This is a pure functional concept that is not frequently used in Rust.</p>
<p>Nevertheless, exploring the concept may be helpful to understand other patterns in Rust APIs, such as <a href="#visitor">visitors</a>. They also have niche use cases.</p>
<p>This is quite a large topic, and would require actual books on language design to fully get into its abilities. However their applicability in Rust is much simpler.</p>
<p>To explain the relevant parts of the concept, the <code>Serde</code>-API will be used as an example, as it is one that is difficult for many to understand from simply the API documentation.</p>
<p>In the process, different specific patterns, called Optics, will be covered. These are <em>The Iso</em>, <em>The Poly Iso</em>, and <em>The Prism</em>.</p>
<h2 id="an-api-example-serde"><a class="header" href="#an-api-example-serde">An API Example: Serde</a></h2>
<p>Trying to understand the way <em>Serde</em> works by only reading the API is a challenge, especially the first time. Consider the <code>Deserializer</code> trait, implemented by any library which parses a new data format:</p>
<pre><code class="language-rust ignore">pub trait Deserializer&lt;'de&gt;: Sized {
    type Error: Error;

    fn deserialize_any&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value, Self::Error&gt;
    where
        V: Visitor&lt;'de&gt;;

    fn deserialize_bool&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value, Self::Error&gt;
    where
        V: Visitor&lt;'de&gt;;

    // remainder omitted
}</code></pre>
<p>And here’s the definition of the <code>Visitor</code> trait passed in generically:</p>
<pre><code class="language-rust ignore">pub trait Visitor&lt;'de&gt;: Sized {
    type Value;

    fn visit_bool&lt;E&gt;(self, v: bool) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: Error;

    fn visit_u64&lt;E&gt;(self, v: u64) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: Error;

    fn visit_str&lt;E&gt;(self, v: &amp;str) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: Error;

    // remainder omitted
}</code></pre>
<p>There is a lot of type erasure going on here, with multiple levels of associated types being passed back and forth.</p>
<p>But what is the big picture? Why not just have the <code>Visitor</code> return the pieces the caller needs in a streaming API, and call it a day? Why all the extra pieces?</p>
<p>One way to understand it is to look at a functional languages concept called <em>optics</em>.</p>
<p>This is a way to do composition of behavior and proprieties that is designed to facilitate patterns common to Rust: failure, type transformation, etc.<sup class="footnote-reference" id="fr-1-1-3"><a href="#footnote-1-3">1</a></sup></p>
<p>The Rust language does not have very good support for these directly. However, they appear in the design of the language itself, and their concepts can help to understand some of Rust’s APIs. As a result, this attempts to explain the concepts with the way Rust does it.</p>
<p>This will perhaps shed light on what those APIs are achieving: specific properties of composability.</p>
<h2 id="basic-optics"><a class="header" href="#basic-optics">Basic Optics</a></h2>
<h3 id="the-iso"><a class="header" href="#the-iso">The Iso</a></h3>
<p>The Iso is a value transformer between two types. It is extremely simple, but a conceptually important building block.</p>
<p>As an example, suppose that we have a custom Hash table structure used as a concordance for a document.<sup class="footnote-reference" id="fr-2-1-1"><a href="#footnote-2-1">2</a></sup> It uses strings for keys (words) and a list of indexes for values (file offsets, for instance).</p>
<p>A key feature is the ability to serialize this format to disk. A “quick and dirty” approach would be to implement a conversion to and from a string in JSON format. (Errors are ignored for the time being, they will be handled later.)</p>
<p>To write it in a normal form expected by functional language users:</p>
<pre><code class="language-text">case class ConcordanceSerDe {
  serialize: Concordance -&gt; String
  deserialize: String -&gt; Concordance
}
</code></pre>
<p>The Iso is thus a pair of functions which convert values of different types: <code>serialize</code> and <code>deserialize</code>.</p>
<p>A straightforward implementation:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

struct Concordance {
    keys: HashMap&lt;String, usize&gt;,
    value_table: Vec&lt;(usize, usize)&gt;,
}

struct ConcordanceSerde {}

impl ConcordanceSerde {
    fn serialize(value: Concordance) -&gt; String {
        todo!()
    }
    // invalid concordances are empty
    fn deserialize(value: String) -&gt; Concordance {
        todo!()
    }
}
<span class="boring">}</span></code></pre>
<p>This may seem rather silly. In Rust, this type of behavior is typically done with traits. After all, the standard library has <code>FromStr</code> and <code>ToString</code> in it.</p>
<p>But that is where our next subject comes in: Poly Isos.</p>
<h3 id="poly-isos"><a class="header" href="#poly-isos">Poly Isos</a></h3>
<p>The previous example was simply converting between values of two fixed types. This next block builds upon it with generics, and is more interesting.</p>
<p>Poly Isos allow an operation to be generic over any type while returning a single type.</p>
<p>This brings us closer to parsing. Consider what a basic parser would do ignoring error cases. Again, this is its normal form:</p>
<pre><code class="language-text">case class Serde[T] {
    deserialize(String) -&gt; T
    serialize(T) -&gt; String
}
</code></pre>
<p>Here we have our first generic, the type <code>T</code> being converted.</p>
<p>In Rust, this could be implemented with a pair of traits in the standard library: <code>FromStr</code> and <code>ToString</code>. The Rust version even handles errors:</p>
<pre><code class="language-rust ignore">pub trait FromStr: Sized {
    type Err;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}

pub trait ToString {
    fn to_string(&amp;self) -&gt; String;
}</code></pre>
<p>Unlike the Iso, the Poly Iso allows application of multiple types, and returns them generically. This is what you would want for a basic string parser.</p>
<p>At first glance, this seems like a good option for writing a parser. Let’s see it in action:</p>
<pre><code class="language-rust ignore">use anyhow;

use std::str::FromStr;

struct TestStruct {
    a: usize,
    b: String,
}

impl FromStr for TestStruct {
    type Err = anyhow::Error;
    fn from_str(s: &amp;str) -&gt; Result&lt;TestStruct, Self::Err&gt; {
        todo!()
    }
}

impl ToString for TestStruct {
    fn to_string(&amp;self) -&gt; String {
        todo!()
    }
}

fn main() {
    let a = TestStruct {
        a: 5,
        b: "hello".to_string(),
    };
    println!("Our Test Struct as JSON: {}", a.to_string());
}</code></pre>
<p>That seems quite logical. However, there are two problems with this.</p>
<p>First, <code>to_string</code> does not indicate to API users, “this is JSON.” Every type would need to agree on a JSON representation, and many of the types in the Rust standard library already don’t. Using this is a poor fit. This can easily be resolved with our own trait.</p>
<p>But there is a second, subtler problem: scaling.</p>
<p>When every type writes <code>to_string</code> by hand, this works. But if every single person who wants their type to be serializable has to write a bunch of code – and possibly different JSON libraries – to do it themselves, it will turn into a mess very quickly!</p>
<p>The answer is one of Serde’s two key innovations: an independent data model to represent Rust data in structures common to data serialization languages. The result is that it can use Rust’s code generation abilities to create an intermediary conversion type it calls a <code>Visitor</code>.</p>
<p>This means, in normal form (again, skipping error handling for simplicity):</p>
<pre><code class="language-text">case class Serde[T] {
    deserialize: Visitor[T] -&gt; T
    serialize: T -&gt; Visitor[T]
}

case class Visitor[T] {
    toJson: Visitor[T] -&gt; String
    fromJson: String -&gt; Visitor[T]
}
</code></pre>
<p>The result is one Poly Iso and one Iso (respectively). Both of these can be implemented with traits:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Serde {
    type V;
    fn deserialize(visitor: Self::V) -&gt; Self;
    fn serialize(self) -&gt; Self::V;
}

trait Visitor {
    fn to_json(self) -&gt; String;
    fn from_json(json: String) -&gt; Self;
}
<span class="boring">}</span></code></pre>
<p>Because there is a uniform set of rules to transform Rust structures to the independent form, it is even possible to have code generation creating the <code>Visitor</code> associated with type <code>T</code>:</p>
<pre><code class="language-rust ignore">#[derive(Default, Serde)] // the "Serde" derive creates the trait impl block
struct TestStruct {
    a: usize,
    b: String,
}

// user writes this macro to generate an associated visitor type
generate_visitor!(TestStruct);</code></pre>
<p>But let’s actually try that approach.</p>
<pre><code class="language-rust ignore">fn main() {
    let a = TestStruct { a: 5, b: "hello".to_string() };
    let a_data = a.serialize().to_json();
    println!("Our Test Struct as JSON: {a_data}");
    let b = TestStruct::deserialize(
        generated_visitor_for!(TestStruct)::from_json(a_data));
}</code></pre>
<p>It turns out that the conversion isn’t symmetric after all! On paper it is, but with the auto-generated code the name of the actual type necessary to convert all the way from <code>String</code> is hidden. We’d need some kind of <code>generated_visitor_for!</code> macro to obtain the type name.</p>
<p>It’s wonky, but it works… until we get to the elephant in the room.</p>
<p>The only format currently supported is JSON. How would we support more formats?</p>
<p>The current design requires completely re-writing all of the code generation and creating a new Serde trait. That is quite terrible and not extensible at all!</p>
<p>In order to solve that, we need something more powerful.</p>
<h2 id="prism"><a class="header" href="#prism">Prism</a></h2>
<p>To take format into account, we need something in normal form like this:</p>
<pre><code class="language-text">case class Serde[T, F] {
    serialize: T, F -&gt; String
    deserialize: String, F -&gt; Result[T, Error]
}
</code></pre>
<p>This construct is called a Prism. It is “one level higher” in generics than Poly Isos (in this case, the “intersecting” type F is the key).</p>
<p>Unfortunately because <code>Visitor</code> is a trait (since each incarnation requires its own custom code), this would require a kind of generic type boundary that Rust does not support.</p>
<p>Fortunately, we still have that <code>Visitor</code> type from before. What is the <code>Visitor</code> doing? It is attempting to allow each data structure to define the way it is itself parsed.</p>
<p>Well what if we could add one more interface for the generic format? Then the <code>Visitor</code> is just an implementation detail, and it would “bridge” the two APIs.</p>
<p>In normal form:</p>
<pre><code class="language-text">case class Serde[T] {
    serialize: F -&gt; String
    deserialize F, String -&gt; Result[T, Error]
}

case class VisitorForT {
    build: F, String -&gt; Result[T, Error]
    decompose: F, T -&gt; String
}

case class SerdeFormat[T, V] {
    toString: T, V -&gt; String
    fromString: V, String -&gt; Result[T, Error]
}
</code></pre>
<p>And what do you know, a pair of Poly Isos at the bottom which can be implemented as traits!</p>
<p>Thus we have the Serde API:</p>
<ol>
<li>Each type to be serialized implements <code>Deserialize</code> or <code>Serialize</code>, equivalent to the <code>Serde</code> class</li>
<li>They get a type (well two, one for each direction) implementing the <code>Visitor</code> trait, which is usually (but not always) done through code generated by a derive macro. This contains the logic to construct or destruct between the data type and the format of the Serde data model.</li>
<li>The type implementing the <code>Deserializer</code> trait handles all details specific to the format, being “driven by” the <code>Visitor</code>.</li>
</ol>
<p>This splitting and Rust type erasure is really to achieve a Prism through indirection.</p>
<p>You can see it on the <code>Deserializer</code> trait</p>
<pre><code class="language-rust ignore">pub trait Deserializer&lt;'de&gt;: Sized {
    type Error: Error;

    fn deserialize_any&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value, Self::Error&gt;
    where
        V: Visitor&lt;'de&gt;;

    fn deserialize_bool&lt;V&gt;(self, visitor: V) -&gt; Result&lt;V::Value, Self::Error&gt;
    where
        V: Visitor&lt;'de&gt;;

    // remainder omitted
}</code></pre>
<p>And the visitor:</p>
<pre><code class="language-rust ignore">pub trait Visitor&lt;'de&gt;: Sized {
    type Value;

    fn visit_bool&lt;E&gt;(self, v: bool) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: Error;

    fn visit_u64&lt;E&gt;(self, v: u64) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: Error;

    fn visit_str&lt;E&gt;(self, v: &amp;str) -&gt; Result&lt;Self::Value, E&gt;
    where
        E: Error;

    // remainder omitted
}</code></pre>
<p>And the trait <code>Deserialize</code> implemented by the macros:</p>
<pre><code class="language-rust ignore">pub trait Deserialize&lt;'de&gt;: Sized {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;;
}</code></pre>
<p>This has been abstract, so let’s look at a concrete example.</p>
<p>How does actual Serde deserialize a bit of JSON into <code>struct Concordance</code> from earlier?</p>
<ol>
<li>The user would call a library function to deserialize the data. This would create a <code>Deserializer</code> based on the JSON format.</li>
<li>Based on the fields in the struct, a <code>Visitor</code> would be created (more on that in a moment) which knows how to create each type in a generic data model that was needed to represent it: <code>Vec</code> (list), <code>u64</code> and <code>String</code>.</li>
<li>The deserializer would make calls to the <code>Visitor</code> as it parsed items.</li>
<li>The <code>Visitor</code> would indicate if the items found were expected, and if not, raise an error to indicate deserialization has failed.</li>
</ol>
<p>For our very simple structure above, the expected pattern would be:</p>
<ol>
<li>Begin visiting a map (<em>Serde</em>’s equivalent to <code>HashMap</code> or JSON’s dictionary).</li>
<li>Visit a string key called “keys”.</li>
<li>Begin visiting a map value.</li>
<li>For each item, visit a string key then an integer value.</li>
<li>Visit the end of the map.</li>
<li>Store the map into the <code>keys</code> field of the data structure.</li>
<li>Visit a string key called “value_table”.</li>
<li>Begin visiting a list value.</li>
<li>For each item, visit an integer.</li>
<li>Visit the end of the list</li>
<li>Store the list into the <code>value_table</code> field.</li>
<li>Visit the end of the map.</li>
</ol>
<p>But what determines which “observation” pattern is expected?</p>
<p>A functional programming language would be able to use currying to create reflection of each type based on the type itself. Rust does not support that, so every single type would need to have its own code written based on its fields and their properties.</p>
<p><em>Serde</em> solves this usability challenge with a derive macro:</p>
<pre><code class="language-rust ignore">use serde::Deserialize;

#[derive(Deserialize)]
struct IdRecord {
    name: String,
    customer_id: String,
}</code></pre>
<p>That macro simply generates an impl block causing the struct to implement a trait called <code>Deserialize</code>.</p>
<p>This is the function that determines how to create the struct itself. Code is generated based on the struct’s fields. When the parsing library is called - in our example, a JSON parsing library - it creates a <code>Deserializer</code> and calls <code>Type::deserialize</code> with it as a parameter.</p>
<p>The <code>deserialize</code> code will then create a <code>Visitor</code> which will have its calls “refracted” by the <code>Deserializer</code>. If everything goes well, eventually that <code>Visitor</code> will construct a value corresponding to the type being parsed and return it.</p>
<p>For a complete example, see the <a href="https://serde.rs/deserialize-struct.html"><em>Serde</em> documentation</a>.</p>
<p>The result is that types to be deserialized only implement the “top layer” of the API, and file formats only need to implement the “bottom layer”. Each piece can then “just work” with the rest of the ecosystem, since generic types will bridge them.</p>
<p>In conclusion, Rust’s generic-inspired type system can bring it close to these concepts and use their power, as shown in this API design. But it may also need procedural macros to create bridges for its generics.</p>
<p>If you are interested in learning more about this topic, please check the following section.</p>
<h2 id="see-also-23"><a class="header" href="#see-also-23">See Also</a></h2>
<ul>
<li><a href="https://crates.io/crates/lens-rs">lens-rs crate</a> for a pre-built lenses implementation, with a cleaner interface than these examples</li>
<li><a href="https://serde.rs">Serde</a> itself, which makes these concepts intuitive for end users (i.e. defining the structs) without needing to understand the details</li>
<li><a href="https://github.com/phaazon/luminance-rs">luminance</a> is a crate for drawing computer graphics that uses similar API design, including procedural macros to create full prisms for buffers of different pixel types that remain generic</li>
<li><a href="https://web.archive.org/web/20221128185849/https://medium.com/zyseme-technology/functional-references-lens-and-other-optics-in-scala-e5f7e2fdafe">An Article about Lenses in Scala</a> that is very readable even without Scala expertise.</li>
<li><a href="https://web.archive.org/web/20220701102832/https://arxiv.org/ftp/arxiv/papers/1703/1703.10857.pdf">Paper: Profunctor Optics: Modular Data Accessors</a></li>
<li><a href="https://github.com/udoprog/musli">Musli</a> is a library which attempts to use a similar structure with a different approach, e.g. doing away with the visitor</li>
</ul>
<footer id="last-change-47">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer>
<hr>
<ol class="footnote-definition">
<li id="footnote-1-3">
<p><a href="https://web.archive.org/web/20221128190041/https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial">School of Haskell: A Little Lens Starter Tutorial</a> <a href="#fr-1-1-3">↩</a></p>
</li>
<li id="footnote-2-1">
<p><a href="https://en.wikipedia.org/wiki/Concordance_(publishing)">Concordance on Wikipedia</a> <a href="#fr-2-1-1">↩</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="additional-resources"><a class="header" href="#additional-resources">Additional resources</a></h1>
<p>A collection of complementary helpful content</p>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=Pm_oO0N5B9k">Design Patterns in Rust</a> by Nicholas Cameron at the PDRust (2016)</li>
<li><a href="https://www.youtube.com/watch?v=0zOg8_B71gE">Writing Idiomatic Libraries in Rust</a> by Pascal Hertleif at RustFest (2017)</li>
<li><a href="https://www.youtube.com/watch?v=vqavdUGKeb4">Rust Programming Techniques</a> by Nicholas Cameron at LinuxConfAu (2018)</li>
</ul>
<h2 id="books-online"><a class="header" href="#books-online">Books (Online)</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines">The Rust API Guidelines</a></li>
</ul>
<footer id="last-change-48">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer><div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h1>
<h2 id="a-brief-overview-over-common-design-principles"><a class="header" href="#a-brief-overview-over-common-design-principles">A brief overview over common design principles</a></h2>
<hr>
<h2 id="solid"><a class="header" href="#solid"><a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a></a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single Responsibility Principle (SRP)</a>: A class should only have a single responsibility, that is, only changes to one part of the software’s specification should be able to affect the specification of the class.</li>
<li><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open/Closed Principle (OCP)</a>: “Software entities … should be open for extension, but closed for modification.”</li>
<li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle (LSP)</a>: “Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.”</li>
<li><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle (ISP)</a>: “Many client-specific interfaces are better than one general-purpose interface.”</li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion Principle (DIP)</a>: One should “depend upon abstractions, [not] concretions.”</li>
</ul>
<h2 id="crp-composite-reuse-principle-or-composition-over-inheritance"><a class="header" href="#crp-composite-reuse-principle-or-composition-over-inheritance"><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">CRP (Composite Reuse Principle) or Composition over inheritance</a></a></h2>
<p>“a the principle that classes should favor polymorphic behavior and code reuse by their composition (by containing instances of other classes that implement the desired functionality) over inheritance from a base or parent class” - Knoernschild, Kirk (2002). Java Design - Objects, UML, and Process</p>
<h2 id="dry-dont-repeat-yourself"><a class="header" href="#dry-dont-repeat-yourself"><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY (Don’t Repeat Yourself)</a></a></h2>
<p>“Every piece of knowledge must have a single, unambiguous, authoritative representation within a system”</p>
<h2 id="kiss-principle"><a class="header" href="#kiss-principle"><a href="https://en.wikipedia.org/wiki/KISS_principle">KISS principle</a></a></h2>
<p>most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided</p>
<h2 id="law-of-demeter-lod"><a class="header" href="#law-of-demeter-lod"><a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter (LoD)</a></a></h2>
<p>a given object should assume as little as possible about the structure or properties of anything else (including its subcomponents), in accordance with the principle of “information hiding”</p>
<h2 id="design-by-contract-dbc"><a class="header" href="#design-by-contract-dbc"><a href="https://en.wikipedia.org/wiki/Design_by_contract">Design by contract (DbC)</a></a></h2>
<p>software designers should define formal, precise and verifiable interface specifications for software components, which extend the ordinary definition of abstract data types with preconditions, postconditions and invariants</p>
<h2 id="encapsulation"><a class="header" href="#encapsulation"><a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">Encapsulation</a></a></h2>
<p>bundling of data with the methods that operate on that data, or the restricting of direct access to some of an object’s components. Encapsulation is used to hide the values or state of a structured data object inside a class, preventing unauthorized parties’ direct access to them.</p>
<h2 id="command-query-separation-cqs"><a class="header" href="#command-query-separation-cqs"><a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">Command-Query-Separation (CQS)</a></a></h2>
<p>“Functions should not produce abstract side effects…only commands (procedures) will be permitted to produce side effects.” - Bertrand Meyer: Object-Oriented Software Construction</p>
<h2 id="principle-of-least-astonishment-pola"><a class="header" href="#principle-of-least-astonishment-pola"><a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">Principle of least astonishment (POLA)</a></a></h2>
<p>a component of a system should behave in a way that most users will expect it to behave. The behavior should not astonish or surprise users</p>
<h2 id="linguistic-modular-units"><a class="header" href="#linguistic-modular-units">Linguistic-Modular-Units</a></h2>
<p>“Modules must correspond to syntactic units in the language used.” - Bertrand Meyer: Object-Oriented Software Construction</p>
<h2 id="self-documentation"><a class="header" href="#self-documentation">Self-Documentation</a></h2>
<p>“The designer of a module should strive to make all information about the module part of the module itself.” - Bertrand Meyer: Object-Oriented Software Construction</p>
<h2 id="uniform-access"><a class="header" href="#uniform-access">Uniform-Access</a></h2>
<p>“All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.” - Bertrand Meyer: Object-Oriented Software Construction</p>
<h2 id="single-choice"><a class="header" href="#single-choice">Single-Choice</a></h2>
<p>“Whenever a software system must support a set of alternatives, one and only one module in the system should know their exhaustive list.” - Bertrand Meyer: Object-Oriented Software Construction</p>
<h2 id="persistence-closure"><a class="header" href="#persistence-closure">Persistence-Closure</a></h2>
<p>“Whenever a storage mechanism stores an object, it must store with it the dependents of that object. Whenever a retrieval mechanism retrieves a previously stored object, it must also retrieve any dependent of that object that has not yet been retrieved.” - Bertrand Meyer: Object-Oriented Software Construction</p>
<footer id="last-change-49">Last change: <time datetime="2025-12-24">2025-12-24</time>, commit: <a href="https://github.com/rust-unofficial/patterns/commit/0f956f1">0f956f1</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-6e739180.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
