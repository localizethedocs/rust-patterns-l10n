msgid ""
msgstr ""
"Project-Id-Version: Rust Design Patterns\n"
"POT-Creation-Date: 2025-12-22T08:31:33Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/idioms/coercion-arguments.md:1
msgid "Use borrowed types for arguments"
msgstr ""

#: src/idioms/coercion-arguments.md:3
msgid "Description"
msgstr ""

#: src/idioms/coercion-arguments.md:5
msgid ""
"Using a target of a deref coercion can increase the flexibility of your code "
"when you are deciding which argument type to use for a function argument. In "
"this way, the function will accept more input types."
msgstr ""

#: src/idioms/coercion-arguments.md:9
msgid ""
"This is not limited to slice-able or fat pointer types. In fact, you should "
"always prefer using the **borrowed type** over **borrowing the owned type**. "
"Such as `&str` over `&String`, `&[T]` over `&Vec<T>`, or `&T` over `&Box<T>`."
msgstr ""

#: src/idioms/coercion-arguments.md:13
msgid ""
"Using borrowed types you can avoid layers of indirection for those instances "
"where the owned type already provides a layer of indirection. For instance, "
"a `String` has a layer of indirection, so a `&String` will have two layers "
"of indirection. We can avoid this by using `&str` instead, and letting "
"`&String` coerce to a `&str` whenever the function is invoked."
msgstr ""

#: src/idioms/coercion-arguments.md:19
msgid "Example"
msgstr ""

#: src/idioms/coercion-arguments.md:21
msgid ""
"For this example, we will illustrate some differences for using `&String` as "
"a function argument versus using a `&str`, but the ideas apply as well to "
"using `&Vec<T>` versus using a `&[T]` or using a `&Box<T>` versus a `&T`."
msgstr ""

#: src/idioms/coercion-arguments.md:25
msgid ""
"Consider an example where we wish to determine if a word contains three "
"consecutive vowels. We don't need to own the string to determine this, so we "
"will take a reference."
msgstr ""

#: src/idioms/coercion-arguments.md:29
msgid "The code might look something like this:"
msgstr ""

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'a'"
msgstr ""

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'e'"
msgstr ""

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'i'"
msgstr ""

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'o'"
msgstr ""

#: src/idioms/coercion-arguments.md:36 src/idioms/coercion-arguments.md:96
msgid "'u'"
msgstr ""

#: src/idioms/coercion-arguments.md:49
msgid "\"Ferris\""
msgstr ""

#: src/idioms/coercion-arguments.md:50
msgid "\"Curious\""
msgstr ""

#: src/idioms/coercion-arguments.md:51 src/idioms/coercion-arguments.md:52
msgid "\"{}: {}\""
msgstr ""

#: src/idioms/coercion-arguments.md:54
msgid ""
"// This works fine, but the following two lines would fail:\n"
"    // println!(\"Ferris: {}\", three_vowels(\"Ferris\"));\n"
"    // println!(\"Curious: {}\", three_vowels(\"Curious\"));\n"
msgstr ""

#: src/idioms/coercion-arguments.md:60
msgid ""
"This works fine because we are passing a `&String` type as a parameter. If "
"we remove the comments on the last two lines, the example will fail. This is "
"because a `&str` type will not coerce to a `&String` type. We can fix this "
"by simply modifying the type for our argument."
msgstr ""

#: src/idioms/coercion-arguments.md:65
msgid "For instance, if we change our function declaration to:"
msgstr ""

#: src/idioms/coercion-arguments.md:71
msgid "then both versions will compile and print the same output."
msgstr ""

#: src/idioms/coercion-arguments.md:78
msgid ""
"But wait, that's not all! There is more to this story. It's likely that you "
"may say to yourself: that doesn't matter, I will never be using a `&'static "
"str` as an input anyways (as we did when we used `\"Ferris\"`). Even "
"ignoring this special example, you may still find that using `&str` will "
"give you more flexibility than using a `&String`."
msgstr ""

#: src/idioms/coercion-arguments.md:84
msgid ""
"Let's now take an example where someone gives us a sentence, and we want to "
"determine if any of the words in the sentence contain three consecutive "
"vowels. We probably should make use of the function we have already defined "
"and simply feed in each word from the sentence."
msgstr ""

#: src/idioms/coercion-arguments.md:89
msgid "An example of this could look like this:"
msgstr ""

#: src/idioms/coercion-arguments.md:110
msgid "\"Once upon a time, there was a friendly curious crab named Ferris\""
msgstr ""

#: src/idioms/coercion-arguments.md:111
msgid "' '"
msgstr ""

#: src/idioms/coercion-arguments.md:113
msgid "\"{word} has three consecutive vowels!\""
msgstr ""

#: src/idioms/coercion-arguments.md:119
msgid ""
"Running this example using our function declared with an argument type "
"`&str` will yield"
msgstr ""

#: src/idioms/coercion-arguments.md:126
msgid ""
"However, this example will not run when our function is declared with an "
"argument type `&String`. This is because string slices are a `&str` and not "
"a `&String` which would require an allocation to be converted to `&String` "
"which is not implicit, whereas converting from `String` to `&str` is cheap "
"and implicit."
msgstr ""

#: src/idioms/coercion-arguments.md:132
msgid "See also"
msgstr ""

#: src/idioms/coercion-arguments.md:134
msgid ""
"[Rust Language Reference on Type Coercions](https://doc.rust-lang.org/"
"reference/type-coercions.html)"
msgstr ""

#: src/idioms/coercion-arguments.md:135
msgid ""
"For more discussion on how to handle `String` and `&str` see [this blog "
"series (2015)](https://web.archive.org/web/20201112023149/https://"
"hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html) by Herman "
"J. Radtke III"
msgstr ""

#: src/idioms/coercion-arguments.md:138
msgid ""
"[Steve Klabnik's Blogpost on 'When should I use String vs &str?'](https://"
"archive.ph/LBpD0)"
msgstr ""
