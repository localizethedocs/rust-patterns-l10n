msgid ""
msgstr ""
"Project-Id-Version: Rust Design Patterns\n"
"POT-Creation-Date: 2025-12-22T08:31:34Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/idioms/priv-extend.md:1
msgid "`#[non_exhaustive]` and private fields for extensibility"
msgstr ""

#: src/idioms/priv-extend.md:3
msgid "Description"
msgstr ""

#: src/idioms/priv-extend.md:5
msgid ""
"A small set of scenarios exist where a library author may want to add public "
"fields to a public struct or new variants to an enum without breaking "
"backwards compatibility."
msgstr ""

#: src/idioms/priv-extend.md:9
msgid "Rust offers two solutions to this problem:"
msgstr ""

#: src/idioms/priv-extend.md:11
msgid ""
"Use `#[non_exhaustive]` on `struct`s, `enum`s, and `enum` variants. For "
"extensive documentation on all the places where `#[non_exhaustive]` can be "
"used, see [the docs](https://doc.rust-lang.org/reference/attributes/"
"type_system.html#the-non_exhaustive-attribute)."
msgstr ""

#: src/idioms/priv-extend.md:16
msgid ""
"You may add a private field to a struct to prevent it from being directly "
"instantiated or matched against (see Alternative)"
msgstr ""

#: src/idioms/priv-extend.md:19
msgid "Example"
msgstr ""

#: src/idioms/priv-extend.md:23
msgid "// Public struct.\n"
msgstr ""

#: src/idioms/priv-extend.md:41
msgid ""
"// Because S is `#[non_exhaustive]`, it cannot be named here and\n"
"    // we must use `..` in the pattern.\n"
msgstr ""

#: src/idioms/priv-extend.md:47
msgid "\"it's an A\""
msgstr ""

#: src/idioms/priv-extend.md:48
msgid "\"it's a b\""
msgstr ""

#: src/idioms/priv-extend.md:50
msgid "// .. required because this variant is non-exhaustive as well\n"
msgstr ""

#: src/idioms/priv-extend.md:51
msgid "\"it's a c\""
msgstr ""

#: src/idioms/priv-extend.md:53
msgid ""
"// The wildcard match is required because more variants may be\n"
"        // added in the future\n"
msgstr ""

#: src/idioms/priv-extend.md:55
msgid "\"it's a new variant\""
msgstr ""

#: src/idioms/priv-extend.md:60
msgid "Alternative: `Private fields` for structs"
msgstr ""

#: src/idioms/priv-extend.md:62
msgid ""
"`#[non_exhaustive]` only works across crate boundaries. Within a crate, the "
"private field method may be used."
msgstr ""

#: src/idioms/priv-extend.md:65
msgid ""
"Adding a field to a struct is a mostly backwards compatible change. However, "
"if a client uses a pattern to deconstruct a struct instance, they might name "
"all the fields in the struct and adding a new one would break that pattern. "
"The client could name some fields and use `..` in the pattern, in which case "
"adding another field is backwards compatible. Making at least one of the "
"struct's fields private forces clients to use the latter form of patterns, "
"ensuring that the struct is future-proof."
msgstr ""

#: src/idioms/priv-extend.md:73
msgid ""
"The downside of this approach is that you might need to add an otherwise "
"unneeded field to the struct. You can use the `()` type so that there is no "
"runtime overhead and prepend `_` to the field name to avoid the unused field "
"warning."
msgstr ""

#: src/idioms/priv-extend.md:81
msgid ""
"// Because `b` is private, you cannot match on `S` without using `..` and "
"`S`\n"
"    //  cannot be directly instantiated or matched against\n"
msgstr ""

#: src/idioms/priv-extend.md:87
msgid "Discussion"
msgstr ""

#: src/idioms/priv-extend.md:89
msgid ""
"On `struct`s, `#[non_exhaustive]` allows adding additional fields in a "
"backwards compatible way. It will also prevent clients from using the struct "
"constructor, even if all the fields are public. This may be helpful, but "
"it's worth considering if you _want_ an additional field to be found by "
"clients as a compiler error rather than something that may be silently "
"undiscovered."
msgstr ""

#: src/idioms/priv-extend.md:95
msgid ""
"`#[non_exhaustive]` can be applied to enum variants as well. A "
"`#[non_exhaustive]` variant behaves in the same way as a `#[non_exhaustive]` "
"struct."
msgstr ""

#: src/idioms/priv-extend.md:99
msgid ""
"Use this deliberately and with caution: incrementing the major version when "
"adding fields or variants is often a better option. `#[non_exhaustive]` may "
"be appropriate in scenarios where you're modeling an external resource that "
"may change out-of-sync with your library, but is not a general purpose tool."
msgstr ""

#: src/idioms/priv-extend.md:104
msgid "Disadvantages"
msgstr ""

#: src/idioms/priv-extend.md:106
msgid ""
"`#[non_exhaustive]` can make your code much less ergonomic to use, "
"especially when forced to handle unknown enum variants. It should only be "
"used when these sorts of evolutions are required **without** incrementing "
"the major version."
msgstr ""

#: src/idioms/priv-extend.md:110
msgid ""
"When `#[non_exhaustive]` is applied to `enum`s, it forces clients to handle "
"a wildcard variant. If there is no sensible action to take in this case, "
"this may lead to awkward code and code paths that are only executed in "
"extremely rare circumstances. If a client decides to `panic!()` in this "
"scenario, it may have been better to expose this error at compile time. In "
"fact, `#[non_exhaustive]` forces clients to handle the \"Something else\" "
"case; there is rarely a sensible action to take in this scenario."
msgstr ""

#: src/idioms/priv-extend.md:118
msgid "See also"
msgstr ""

#: src/idioms/priv-extend.md:120
msgid ""
"[RFC introducing #\\[non_exhaustive\\] attribute for enums and structs]"
"(https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)"
msgstr ""
