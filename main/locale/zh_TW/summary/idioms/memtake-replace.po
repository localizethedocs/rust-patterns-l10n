msgid ""
msgstr ""
"Project-Id-Version: Rust Design Patterns\n"
"POT-Creation-Date: 2025-12-19T08:35:13Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/idioms/mem-replace.md:1
msgid "`mem::{take(_), replace(_)}` to keep owned values in changed enums"
msgstr ""

#: src/idioms/mem-replace.md:3
msgid "Description"
msgstr ""

#: src/idioms/mem-replace.md:5
msgid ""
"Say we have a `&mut MyEnum` which has (at least) two variants, `A { name: "
"String, x: u8 }` and `B { name: String }`. Now we want to change `MyEnum::A` "
"to a `B` if `x` is zero, while keeping `MyEnum::B` intact."
msgstr ""

#: src/idioms/mem-replace.md:9
msgid "We can do this without cloning the `name`."
msgstr ""

#: src/idioms/mem-replace.md:11
msgid "Example"
msgstr ""

#: src/idioms/mem-replace.md:23
msgid ""
"// This takes out our `name` and puts in an empty String instead\n"
"        // (note that empty strings don't allocate).\n"
"        // Then, construct the new enum variant (which will\n"
"        // be assigned to `*e`).\n"
msgstr ""

#: src/idioms/mem-replace.md:34
msgid "This also works with more variants:"
msgstr ""

#: src/idioms/mem-replace.md:49
msgid ""
"// Ownership rules do not allow taking `name` by value, but we cannot\n"
"        // take the value out of a mutable reference, unless we replace it:\n"
msgstr ""

#: src/idioms/mem-replace.md:63
msgid "Motivation"
msgstr ""

#: src/idioms/mem-replace.md:65
msgid ""
"When working with enums, we may want to change an enum value in place, "
"perhaps to another variant. This is usually done in two phases to keep the "
"borrow checker happy. In the first phase, we observe the existing value and "
"look at its parts to decide what to do next. In the second phase we may "
"conditionally change the value (as in the example above)."
msgstr ""

#: src/idioms/mem-replace.md:71
msgid ""
"The borrow checker won't allow us to take out `name` of the enum (because "
"_something_ must be there.) We could of course `.clone()` name and put the "
"clone into our `MyEnum::B`, but that would be an instance of the [Clone to "
"satisfy the borrow checker](../anti_patterns/borrow_clone.md) anti-pattern. "
"Anyway, we can avoid the extra allocation by changing `e` with only a "
"mutable borrow."
msgstr ""

#: src/idioms/mem-replace.md:78
msgid ""
"`mem::take` lets us swap out the value, replacing it with its default value, "
"and returning the previous value. For `String`, the default value is an "
"empty `String`, which does not need to allocate. As a result, we get the "
"original `name` _as an owned value_. We can then wrap this in another enum."
msgstr ""

#: src/idioms/mem-replace.md:83
msgid ""
"**NOTE:** `mem::replace` is very similar, but allows us to specify what to "
"replace the value with. An equivalent to our `mem::take` line would be `mem::"
"replace(name, String::new())`."
msgstr ""

#: src/idioms/mem-replace.md:87
msgid ""
"Note, however, that if we are using an `Option` and want to replace its "
"value with a `None`, `Option`’s `take()` method provides a shorter and more "
"idiomatic alternative."
msgstr ""

#: src/idioms/mem-replace.md:91
msgid "Advantages"
msgstr ""

#: src/idioms/mem-replace.md:93
msgid ""
"Look ma, no allocation! Also you may feel like Indiana Jones while doing it."
msgstr ""

#: src/idioms/mem-replace.md:95
msgid "Disadvantages"
msgstr ""

#: src/idioms/mem-replace.md:97
msgid ""
"This gets a bit wordy. Getting it wrong repeatedly will make you hate the "
"borrow checker. The compiler may fail to optimize away the double store, "
"resulting in reduced performance as opposed to what you'd do in unsafe "
"languages."
msgstr ""

#: src/idioms/mem-replace.md:101
msgid ""
"Furthermore, the type you are taking needs to implement the [`Default` trait]"
"(./default.md). However, if the type you're working with doesn't implement "
"this, you can instead use `mem::replace`."
msgstr ""

#: src/idioms/mem-replace.md:105
msgid "Discussion"
msgstr ""

#: src/idioms/mem-replace.md:107
msgid ""
"This pattern is only of interest in Rust. In GC'd languages, you'd take the "
"reference to the value by default (and the GC would keep track of refs), and "
"in other low-level languages like C you'd simply alias the pointer and fix "
"things later."
msgstr ""

#: src/idioms/mem-replace.md:112
msgid ""
"However, in Rust, we have to do a little more work to do this. An owned "
"value may only have one owner, so to take it out, we need to put something "
"back in – like Indiana Jones, replacing the artifact with a bag of sand."
msgstr ""

#: src/idioms/mem-replace.md:116
msgid "See also"
msgstr ""

#: src/idioms/mem-replace.md:118
msgid ""
"This gets rid of the [Clone to satisfy the borrow checker](../anti_patterns/"
"borrow_clone.md) anti-pattern in a specific case."
msgstr ""
