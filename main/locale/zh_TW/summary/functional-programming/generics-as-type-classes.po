msgid ""
msgstr ""
"Project-Id-Version: Rust Design Patterns\n"
"POT-Creation-Date: 2025-12-19T08:35:13Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/functional/generics-type-classes.md:1
msgid "Generics as Type Classes"
msgstr ""

#: src/functional/generics-type-classes.md:3
msgid "Description"
msgstr ""

#: src/functional/generics-type-classes.md:5
msgid ""
"Rust's type system is designed more like functional languages (like Haskell) "
"rather than imperative languages (like Java and C++). As a result, Rust can "
"turn many kinds of programming problems into \"static typing\" problems. "
"This is one of the biggest wins of choosing a functional language, and is "
"critical to many of Rust's compile time guarantees."
msgstr ""

#: src/functional/generics-type-classes.md:11
msgid ""
"A key part of this idea is the way generic types work. In C++ and Java, for "
"example, generic types are a meta-programming construct for the compiler. "
"`vector<int>` and `vector<char>` in C++ are just two different copies of the "
"same boilerplate code for a `vector` type (known as a `template`) with two "
"different types filled in."
msgstr ""

#: src/functional/generics-type-classes.md:17
msgid ""
"In Rust, a generic type parameter creates what is known in functional "
"languages as a \"type class constraint\", and each different parameter "
"filled in by an end user _actually changes the type_. In other words, "
"`Vec<isize>` and `Vec<char>` _are two different types_, which are recognized "
"as distinct by all parts of the type system."
msgstr ""

#: src/functional/generics-type-classes.md:23
msgid ""
"This is called **monomorphization**, where different types are created from "
"**polymorphic** code. This special behavior requires `impl` blocks to "
"specify generic parameters. Different values for the generic type cause "
"different types, and different types can have different `impl` blocks."
msgstr ""

#: src/functional/generics-type-classes.md:28
msgid ""
"In object-oriented languages, classes can inherit behavior from their "
"parents. However, this allows the attachment of not only additional behavior "
"to particular members of a type class, but extra behavior as well."
msgstr ""

#: src/functional/generics-type-classes.md:32
msgid ""
"The nearest equivalent is the runtime polymorphism in Javascript and Python, "
"where new members can be added to objects willy-nilly by any constructor. "
"However, unlike those languages, all of Rust's additional methods can be "
"type checked when they are used, because their generics are statically "
"defined. That makes them more usable while remaining safe."
msgstr ""

#: src/functional/generics-type-classes.md:38
msgid "Example"
msgstr ""

#: src/functional/generics-type-classes.md:40
msgid ""
"Suppose you are designing a storage server for a series of lab machines. "
"Because of the software involved, there are two different protocols you need "
"to support: BOOTP (for PXE network boot), and NFS (for remote mount storage)."
msgstr ""

#: src/functional/generics-type-classes.md:44
msgid ""
"Your goal is to have one program, written in Rust, which can handle both of "
"them. It will have protocol handlers and listen for both kinds of requests. "
"The main application logic will then allow a lab administrator to configure "
"storage and security controls for the actual files."
msgstr ""

#: src/functional/generics-type-classes.md:49
msgid ""
"The requests from machines in the lab for files contain the same basic "
"information, no matter what protocol they came from: an authentication "
"method, and a file name to retrieve. A straightforward implementation would "
"look something like this:"
msgstr ""

#: src/functional/generics-type-classes.md:66
msgid ""
"This design might work well enough. But now suppose you needed to support "
"adding metadata that was _protocol specific_. For example, with NFS, you "
"wanted to determine what their mount point was in order to enforce "
"additional security rules."
msgstr ""

#: src/functional/generics-type-classes.md:71
msgid ""
"The way the current struct is designed leaves the protocol decision until "
"runtime. That means any method that applies to one protocol and not the "
"other requires the programmer to do a runtime check."
msgstr ""

#: src/functional/generics-type-classes.md:75
msgid "Here is how getting an NFS mount point would look:"
msgstr ""

#: src/functional/generics-type-classes.md:85
msgid "// ... other methods ...\n"
msgstr ""

#: src/functional/generics-type-classes.md:87
msgid ""
"/// Gets an NFS mount point if this is an NFS request. Otherwise,\n"
"    /// return None.\n"
msgstr ""

#: src/functional/generics-type-classes.md:95
msgid ""
"Every caller of `mount_point()` must check for `None` and write code to "
"handle it. This is true even if they know only NFS requests are ever used in "
"a given code path!"
msgstr ""

#: src/functional/generics-type-classes.md:99
msgid ""
"It would be far more optimal to cause a compile-time error if the different "
"request types were confused. After all, the entire path of the user's code, "
"including what functions from the library they use, will know whether a "
"request is an NFS request or a BOOTP request."
msgstr ""

#: src/functional/generics-type-classes.md:104
msgid ""
"In Rust, this is actually possible! The solution is to _add a generic type_ "
"in order to split the API."
msgstr ""

#: src/functional/generics-type-classes.md:107
msgid "Here is what that looks like:"
msgstr ""

#: src/functional/generics-type-classes.md:114
msgid "// NFS session management omitted\n"
msgstr ""

#: src/functional/generics-type-classes.md:118
msgid "// no authentication in bootp\n"
msgstr ""

#: src/functional/generics-type-classes.md:120
msgid ""
"// Keep the module private to prevent outside users from inventing their own "
"protocols.\n"
msgstr ""

#: src/functional/generics-type-classes.md:149
msgid "// no additional metadata\n"
msgstr ""

#: src/functional/generics-type-classes.md:159
msgid "// keep internal to prevent impls\n"
msgstr ""

#: src/functional/generics-type-classes.md:160
msgid "// re-export so callers can see them\n"
msgstr ""

#: src/functional/generics-type-classes.md:166
msgid "// all common API parts go into a generic impl block\n"
msgstr ""

#: src/functional/generics-type-classes.md:177
msgid "// all protocol-specific impls go into their own block\n"
msgstr ""

#: src/functional/generics-type-classes.md:186
msgid "// your code here\n"
msgstr ""

#: src/functional/generics-type-classes.md:190
msgid ""
"With this approach, if the user were to make a mistake and use the wrong "
"type;"
msgstr ""

#: src/functional/generics-type-classes.md:197
msgid "\"/secure\""
msgstr ""

#: src/functional/generics-type-classes.md:197
msgid "\"Access denied\""
msgstr ""

#: src/functional/generics-type-classes.md:198
msgid "// continue on...\n"
msgstr ""

#: src/functional/generics-type-classes.md:200
msgid "// Rest of the code here\n"
msgstr ""

#: src/functional/generics-type-classes.md:205
msgid ""
"They would get a syntax error. The type `FileDownloadRequest<Bootp>` does "
"not implement `mount_point()`, only the type `FileDownloadRequest<Nfs>` "
"does. And that is created by the NFS module, not the BOOTP module of course!"
msgstr ""

#: src/functional/generics-type-classes.md:209
msgid "Advantages"
msgstr ""

#: src/functional/generics-type-classes.md:211
msgid ""
"First, it allows fields that are common to multiple states to be de-"
"duplicated. By making the non-shared fields generic, they are implemented "
"once."
msgstr ""

#: src/functional/generics-type-classes.md:214
msgid ""
"Second, it makes the `impl` blocks easier to read, because they are broken "
"down by state. Methods common to all states are typed once in one block, and "
"methods unique to one state are in a separate block."
msgstr ""

#: src/functional/generics-type-classes.md:218
msgid ""
"Both of these mean there are fewer lines of code, and they are better "
"organized."
msgstr ""

#: src/functional/generics-type-classes.md:220
msgid "Disadvantages"
msgstr ""

#: src/functional/generics-type-classes.md:222
msgid ""
"This currently increases the size of the binary, due to the way "
"monomorphization is implemented in the compiler. Hopefully the "
"implementation will be able to improve in the future."
msgstr ""

#: src/functional/generics-type-classes.md:226
msgid "Alternatives"
msgstr ""

#: src/functional/generics-type-classes.md:228
msgid ""
"If a type seems to need a \"split API\" due to construction or partial "
"initialization, consider the [Builder Pattern](../patterns/creational/"
"builder.md) instead."
msgstr ""

#: src/functional/generics-type-classes.md:232
msgid ""
"If the API between types does not change -- only the behavior does -- then "
"the [Strategy Pattern](../patterns/behavioural/strategy.md) is better used "
"instead."
msgstr ""

#: src/functional/generics-type-classes.md:236
msgid "See also"
msgstr ""

#: src/functional/generics-type-classes.md:238
msgid "This pattern is used throughout the standard library:"
msgstr ""

#: src/functional/generics-type-classes.md:240
msgid ""
"`Vec<u8>` can be cast from a String, unlike every other type of `Vec<T>`.[^1]"
msgstr ""

#: src/functional/generics-type-classes.md:241
msgid ""
"Iterators can be cast into a binary heap, but only if they contain a type "
"that implements the `Ord` trait.[^2]"
msgstr ""

#: src/functional/generics-type-classes.md:243
msgid ""
"The `to_string` method was specialized for `Cow` only of type `str`.[^3]"
msgstr ""

#: src/functional/generics-type-classes.md:245
msgid "It is also used by several popular crates to allow API flexibility:"
msgstr ""

#: src/functional/generics-type-classes.md:247
msgid ""
"The `embedded-hal` ecosystem used for embedded devices makes extensive use "
"of this pattern. For example, it allows statically verifying the "
"configuration of device registers used to control embedded pins. When a pin "
"is put into a mode, it returns a `Pin<MODE>` struct, whose generic "
"determines the functions usable in that mode, which are not on the `Pin` "
"itself. [^4]"
msgstr ""

#: src/functional/generics-type-classes.md:253
msgid ""
"The `hyper` HTTP client library uses this to expose rich APIs for different "
"pluggable requests. Clients with different connectors have different methods "
"on them as well as different trait implementations, while a core set of "
"methods apply to any connector. [^5]"
msgstr ""

#: src/functional/generics-type-classes.md:258
msgid ""
"The \"type state\" pattern -- where an object gains and loses API based on "
"an internal state or invariant -- is implemented in Rust using the same "
"basic concept, and a slightly different technique. [^6]"
msgstr ""

#: src/functional/generics-type-classes.md:262
msgid ""
"See: [impl From\\<CString\\> for Vec\\<u8\\>](https://doc.rust-lang."
"org/1.59.0/src/std/ffi/c_str.rs.html#803-811)"
msgstr ""

#: src/functional/generics-type-classes.md:265
msgid ""
"See: [impl\\<T: Ord\\> FromIterator\\<T\\> for BinaryHeap\\<T\\>](https://"
"web.archive.org/web/20201030132806/https://doc.rust-lang.org/stable/src/"
"alloc/collections/binary_heap.rs.html#1330-1335)"
msgstr ""

#: src/functional/generics-type-classes.md:268
msgid ""
"See: [impl\\<'\\_\\> ToString for Cow\\<'\\_, str>](https://doc.rust-lang."
"org/stable/src/alloc/string.rs.html#2235-2240)"
msgstr ""

#: src/functional/generics-type-classes.md:271
msgid ""
"Example: [https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/gpioa/"
"struct.PA0.html](https://docs.rs/stm32f30x-hal/0.1.0/stm32f30x_hal/gpio/"
"gpioa/struct.PA0.html)"
msgstr ""

#: src/functional/generics-type-classes.md:274
msgid ""
"See: [https://docs.rs/hyper/0.14.5/hyper/client/struct.Client.html](https://"
"docs.rs/hyper/0.14.5/hyper/client/struct.Client.html)"
msgstr ""

#: src/functional/generics-type-classes.md:277
msgid ""
"See: [The Case for the Type State Pattern](https://web.archive.org/"
"web/20210325065112/https://www.novatec-gmbh.de/en/blog/the-case-for-the-"
"typestate-pattern-the-typestate-pattern-itself/) and [Rusty Typestate Series "
"(an extensive thesis)](https://web.archive.org/web/20210328164854/https://"
"rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-index)"
msgstr ""
